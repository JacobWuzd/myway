近三月复习计划

## HTML篇（6.15）

- [ ] 基本文档规范
  1. <!DOCTYPPE html>标签声明是用来告知web浏览器使用哪种规范来编译文件
  2. <html lang="zh">lang属性声明文档语言类型，便于语音合成工具确定翻译时所遵循的规则
  3. <link rel="shortcut icon" herf="连接"/> 网页图标
  4. title 标签声明，方便用户一目了然页面内容概况。
  5. css在head标签内引入，js在body标签最下方引入
  
- [ ] H5新标签和语义化
  - article：定义文档内的文章
  - aside：定义一个与页面其余内容无关的部分，不会使整体受影响，如侧边栏
  - section：定义文档中的节，即分段
  - header：定义区段或页面的页眉（头部）
  - footer：定义区段或页面的脚部
  - nav：定义导航
  - audio：定义声音内容
  - source：定义媒介源
  - track：定义用在媒体播放器中的文本轨道
  - video：定义视频
  - canvas：定义图形容器
  - progress：定义进度
  
- [ ] meta属性以及其用途

  meta元素写在head标签内，用于指定网页的元数据，可被浏览器、搜索引擎或其他web服务解析调用

  meta语法：<meta name="" content=""/>

  属性：

  - charset：声明文档的字符编码，其值必须是与ASCII大小写无关的“utf-8”，仅html5中可直接用

  - content：包含了http-equiv或name属性的值，具体取决于所使用的的值

  - http-equiv：定义一个编译指示指令，它所有允许的值都是HTTP头部名称：
    
    - content-security-policy(网页安全政策)：允许站点管理控制加载哪些资源
    
      限制：
    
      1. script-src: 外部js脚本地址限制
      2. style-src：样式表地址限制
      3. img-src：图像资源
      4. media-src：媒体资源，限制audio、video、track标签加载媒体资源
      5. font-src：字体文件
      6. object-src：插件资源，限制object、embed、applet标签的源地址
      7. child-src：框架（如frame、iframe和web workers）
      8. frame-ancestors：嵌入的外部资源
      9. form-action：限制form的action属性的连接地址
      10. navigation-to：限制文档可以用a、form、window.location、window.open等方式访问
      11. Referrer-Policy：指定离开当前页面跳转连接的referer header信息
      12. connect-src：HTTP连接（如xhr，websockets）
      13. worker-src：worker脚本源地址限制
      14. manifest-src：限制应用声明文件的源地址
      15. prefetch-src：指定预加载或预渲染的允许源地址
      16. default-src：为上面每个属性设置默认值
    
      每个限制的选项值：
    
      1. 主机名：example.org， https://example.com:443
      2. 路径名：`example.org/resources/js/`
      3. 通配符：`*.example.org`，`*://*.example.com:*`（表示任意协议、任意子域名、任意端口）
      4. 协议名：`https:`、`data:`
      5. 关键字`'self'`：当前域名，需要加引号
      6. 关键字`'none'`：禁止加载任何外部资源，需要加引号
    
    - content-type：只能用于text/html文档，其值必须是“text/html; charset=utf-8”
    
    - default-style：设置默认css样式表组名称
    
    - x-ua-compatible：表示兼容IE浏览器哪些版本来渲染页面，如果指定，内容通常是“IE=edge”，如果用户代理可以忽略这个属性
    
    - refresh：如果content只包含一个整数，则是重新载入页面的时间间隔秒数；如果整数后面跟着一个字符串“;url=”和一个合法的URL，则是重定向到该页面的时间间隔秒数。一般不推荐使用这个属性。
    
  - name：和content一起用，name指元数据名称，content是元数据值

    - application-name：定义正运行在改网页上的网络应用名称
    
    - author：文档作者名称
    
    - description：网页的简短描述
    
    - generator：包含生成页面的软件的标识符
    
    - keywords：网页内容关键字，以逗号隔开，方便搜索引擎抓取
    
    - viewport：提供有关视口初始大小提示，仅供移动设备使用
      1. width：一个整数或者字符串device-width（默认），表示以pixels为单位定义视口宽度
      2. height：同上，默认device-height
      3. initial-scale：一个0.0到10.0之间的正数，定义设备与视口大小之间的缩放比率
      4. maximum-scale：一个0.0到10.0之间的正数，定义缩放最大值，必须大于等于minimum-scale的值
      5. minimum-scale：定义缩放最小值，小于等于maximum-sacle
      6. user-scalable：一个布尔值（yes或者no），默认yes，如果设置为no，用户将不能放大或缩小网页
      7. miniual-ui：ios的safari为meta表天新增的属性，在网页加载是隐藏顶部的地址栏和底部的导航栏
      
    - referrer：控制所有从该文档发出的HTTP请求中HTTP referer首部的内容
    
      content取值：
    
      1. no-referrer：不要发送HTTP referer首部
      2. origin：发送当前文档的origin
      3. no-referrer-when-downgrade：当目的地是先验安全的则发送origin作为referrer，如果目的地是较不安全的则不发送referrer，该项为默认行为
      4. origin-when-crossorigin：在同源请求下，发送完整的URL（不含查询参数），其他情况下则仅发送当前文档的origin
      5. unsafe-URL：在同源请求下，发送完整的URL（不含参数）
    
    - robots：定义爬虫程序应该具有的页面行为，其值用逗号隔开，值如下：
    
      1. index：允许机器人索引页面
      2. noindex：防止机器人索引页面
      3. follow：允许机器人跟随页面上的连接
      4. nofollow：不允许机器人跟随页面上的连接
      5. noodp：再为本页产生标题或页面摘要时，不要使用开放式目录项目中的文本
      6. noarchive：阻止搜索引擎缓存页面内容
      7. nosnippet：防止在搜索引擎结果页中显示该页任何描述
      8. noimageindex：防止本页作为索引图片的引用出现
      
    - format-detection：检测网页中的格式，具体如下：
    
      name=”format-detection” content=”telephone=no,email=no,adress=no”
    
      表示禁止数字文本拨号，禁止作为邮箱地址，禁止转至地图
    
    - apple-mobile-web-app-title：添加到IOS主屏后的标题
    
    - apple-mobile-web-app-status-bar-style：控制苹果顶部状态栏的样式，如content=“black”
    
    - 

- [ ] 适配方式

  - PC

    1. 百分比适配，缺点是所有属性都得用百分比，但是一些属性不支持百分比
    2. 版心布局：首先固定内容区域宽度，如果窗口宽度大于内容区域则居中显示，如果窗口宽度小于内容区域则显示横向滚动条
    3. 媒介查询

  - mobile

    1. flexible方案

       缺点：

       1.动态修改viewport具有风险，改变了缩放之后，视口宽高获取的值会跟着变

       2.非纯CSS方案，需要JS做辅助

       3.存在兼容问题，viewport缩放属性不支持安卓4.4以下的版本

    2. vh（viewport height）/vw（viewport width）方案：

       将视觉视口宽度window.innerWidth和视口高度window.innerHeight等分为100份，1vh = 1% height， 1vw = 1%width。

       vmin：vw和vh中较小值；vmax：vw和vh中较大值

       可用postcss-px-to-viewport插件去完成单位换算

       缺点：1.不能完全整除，可能有一点误差值；2.单位不统一时可能造成宽度超过100vw；3.1px边框显示问题；4.无法限制视口最大或最小宽度时显示问题

       处理1px问题：

       计算dpr，border-width = 1/dpr px。可以配合缩放属性scale完成；渐变实现；图片实现（base64）；svg嵌入到background

    3. viewport-fit：适配iPhonex，限制页面在安全区域内进行展示

       contain：可视窗口完全包含网页内容

       cover：网页内容完全覆盖可视窗口

       safe-area-inset-left：安全区域距离左边界距离

       safe-area-inset-right：安全区域距离右边界距离

       safe-area-inset-top：安全区域距离上边界距离

       safe-area-inset-bottom：安全区域距离下边界距离

       使用：

       <meta name="viewport" content="viewport-fit=cover"></meta>

       <style>
           body {
               padding-bottom: constant(safe-area-inset-bottom);
               padding-bottom: env(safe-area-inset-bottom)
           }
       </style>

    4. media查询
  
- [ ] web Workers

  - 是HTML5提供的一个JS多线程解决方案，可以将一些大计算量的代码交给web workers运行而不冻结用户界面，因为workers分线程没有window对象，也就没有DOM方法 

  - 运用web workers时，子线程完全受主线程控制，且不能操作DOM，因此这个新标准并没有改变JS为单线程的本质

  - 使用方法：

    - 创建在分线程执行的JS文件
    - 在主线程中的JS中发消息并设置回调

  - 创建方式：

    - ```js
      // 主线程中
      // 创建一个workers对象
      var work = new Workers('worker.js')
      // 绑定接收消息的监听
      work..onmessage = function (event) {
          alert(event.data) // 主线程接收分线程返回的数据
      }
      // 向分线程发送消息
      work.postMessage(data)
      
      // 分线程中worker.js
      var onmessage = function (event) {
          var data = event.data // 分线程接收主线程的数据
          // 分线程代码段
          ...
          postMessage(subData) // 分线程向主线程返回数据
      }
      ```

  - 缺点

    - 慢
    - 不能跨域加载JS
    - worker内的代码不能操作window里的数据
    - 不是每个浏览器都支持这个新特性

## css篇（6.17）

- [ ] width几大属性：

  - fill-available：即填满盒子剩余空间，效果同width:100%
  - fit-content：收缩与包裹，将盒子的宽度收缩为内容的宽度
  - min-content：采用盒子中宽度最小的子元素的宽度作为容器盒子的宽度
  - max-content：采用盒子中宽度最大的子元素的宽度作为容器盒子的宽度

- [ ] 盒子模型（IE与标准）

  盒子由4个模块组成：padding、margin、border、content

  - IE盒子模型：contentWidth = content + padding + border

  - 标准盒子模型： contentWidth = content 

  - 切换盒子模型类型：

    1、标准盒子：box-sizing：content-box (默认)

    2、IE盒子：box-sizing：border-box

- [ ] 5种定位方式

  - static：文档中的默认值，没有定位，不受top，bottom，right，left影响
  - fixed：固定定位，相对浏览器窗口定位，脱离文档流，不占据空间，可以和其他元素重叠
  - relative：相对定位，相对于相邻元素正常文档流位置定位，常被作为absolute的容器
  - absolute：绝对定位，相对于最近的已定位的父元素定位，如果父元素没有已定位的，则相对于html标签定位
  - sticky：粘性定位，基于用户的滚动位置来定位。当位置未超出目标区域时，它效果同relative，如果超出，其效果同fixed，固定到定位的那个位置上。该属性必须设置top、right、bottom、left之一，否则效果跟relative一样。
  - z-index：该属性并非定位属性，而是处理定位后的覆盖问题，设置覆盖的优先级

- [ ] BFC(block formatting context) 块格式化上下文：是web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。它是页面中一个隔离的独立容器，容器里面的子元素不受外部元素影响，也不会影响到外部元素。

  创建方式：

  - 根元素html标签
  - 浮动元素float值不为none
  - 绝对定位元素，position值为absolute或fixed
  - 行内块元素，display：inline-block
  - overflow值不为visible的块级元素
  - display：flow-root的元素
  - display：flex或inline-flex或grid或inline-gird
  - 表格单元格：display：table-cell
  - 表格标题：display：table-caption

  特性：

  - BFC内部的块级元素会在垂直方向上一个接着一个的放置
  - 同BFC内部的相邻块级元素在垂直方向上的距离由margin决定，且会发生垂直外边距重叠现象
  - BFC内部每个元素的坐外边界与包含块的左外边界相接触，即时浮动元素也是如此
  - BFC的区域不会与其他float元素区域重叠
  - 计算BFC的高度时，浮动子元素也参与计算

  应用场景：

  - 浮动定位与清除浮动：浮动定位和清除浮动时只会应用于同一个BFC内的元素，浮动不会影响其他BFC中的元素布局，清除浮动也只能清除所在同一个BFC中在它前面的元素的浮动。
  - 外边距折叠（重叠）：只发生在属于同一个BFC的块级元素之间，给任意一个相邻块级盒子外包一个div，使他成为一个新的BFC，即可阻止重叠
  - 阻止因为浏览器四舍五入计算宽度造成的多栏布局换行的情况，可在最后一列触发BFC来阻止换行
  - 两栏布局时，当左侧盒子浮动之后，右侧盒子可以触发BFC，达到自适应

  

- [ ] 外边距重叠：当块级元素的上外边距和下外边距同时都设定时只会保留最大边距

  - 同一层相邻元素之间
  - 没有内容将父元素和后代元素分开，即父元素的上下外边距没有被子元素或内部高度撑开
  - 空的块级元素：一个元素没有子元素也没有内边距或边框或最小最大高度来撑开

- [ ] 浮动与清除浮动的方式

  - 浮动：意味使用块布局，在某些情况下修改display值的计算值
    - left：元素必须浮动在其所在块容器左侧
    - right：元素必须浮动在其所在块容器右侧
    - none：不进行浮动
    - inline-start：元素浮动在所在块容器的开始一侧
    - inline-end：元素浮动在所在块容器的结束一侧
  - 浮动异常情况：由于浮动的元素会脱离文档流，当浮动容器的高度不能大于浮动元素的高度时，就会出现高度塌陷的现象，处理这个现象需清除浮动
  - 清除浮动：
    - clear：指定一个元素是否必须在清除浮动后移动到它之前的浮动元素下面，适用于浮动与非浮动元素，用于浮动元素时，该元素会移动到所有浮动元素外边框边界下方，会影响后面的浮动元素布局，导致后面的浮动元素的位置无法高于它之前的元素；当用在非浮动元素上，这个元素会移动到所有浮动元素下方，且垂直外边距会折叠
    - 在浮动所在容器中添加伪类after，伪类中使用display：block；clear：both，并给容器添加zoom：1
    - 在浮动所在容器最后添加空盒子，并设置clear属性
    - 为浮动元素的父元素添加一个overflow不为visible的属性，触发BFC
    - 双伪类方式，给浮动元素的父元素添加双伪类，均display：block；clear：both
    - 如果布局高度固定，父级给出精确高度

- [ ] 伪类、伪元素相关应用

  - 伪类：指添加到选择器的关键字，指定要选择的元素的特殊状态，一个选择器可以写多个伪类
  - 常见伪元素：
    - input:checked：所有选中的表单元素，通常用于单选框和复选框
    - input:disabled：选择所有禁用的表单元素
    - p:empty：选择所有没有子元素的p元素
    - input:enabled：选择所有启用的表单元素
    - :first-of-type：表示一组兄弟元素中其类型的第一个元素
    - :first-child：表示在一组兄弟元素中的第一个元素
    - last-of-type：表示在父元素的子元素列表中，最后一个给定类型的元素；tagName:last-of-type的作用域包含父元素的所有子元素中最后一个选定元素
    - :last-child：表示父元素的最后一个子元素
    - nth-child(an+b)：a、b均为整数，表示匹配当前元素的兄弟元素中的第an+b个元素，有如下几种情况：
      1. (0n+m)或直接(m)：表示匹配第m个兄弟元素
      2. (1n+0)或(n)：表示匹配每一个兄弟元素
      3. (2n+0)或(2n)：表示匹配2、4、6、8...，也可用关键字even表示，匹配偶数项
      4. (2n+1)：表示匹配奇数项，可用odd来表示
      5. (3n+4)：0,7,10,13...的兄弟元素
    - nth-last-child(an+b)：兄弟元素中从后往前匹配某些位置的元素
    - nth-of-type(n)：针对具有一组兄弟节点的标签，用n来筛选出在一组兄弟节点的位置
    - :nth-last-of-type(an+b)：从后往前匹配相同节点标签的位置
    - only-child：匹配没有兄弟元素的元素，等效:first-child:last-child或:nth-child(1):nth-last-child(1)
    - :only-of-type：代表任意一个元素，这个元素没有其他相同类型的兄弟元素
    - not(selector)：选择所有selector以外的元素，不可嵌套伪类
    - :link：选择所有未访问的链接
    - :visited：选择所有访问过的链接
    - active：选择正则活动链接
    - :hover：鼠标悬停
    - :focus：输入框聚焦后
    - :first-letter：该元素中的第一个字符
    - :first-line：该元素的第一行
    - :before：在该元素之前插入内容
    - :after：在该元素之后插入内容

- [ ] 布局

  - flex盒子布局

    盒子的属性：

    - flex-direction：决定主轴排列方向
      1. row：默认值，主轴为水平方向从左到右
      2. row-reverse：主轴为水平方向从右到左
      3. column：主轴为垂直方向从上到下
      4. column-reverse：主轴为垂直方向从下到上
    - flex-wrap：默认排列下所有子元素都排列在同一条轴线上，该属性决定如果排列不下如何换行
      1. nowrap：默认，不换行
      2. wrap：换行，第一行在上方
      3. wrap-reverse：换行，第一行在下方
    - flex-flow：是flex-direction与flex-wrap的简写方式，默认为 row nowrap
    - justify-content：定义项目在主轴上的对齐方式
      1. flex-start：默认，左对齐
      2. flex-end：右对齐
      3. center：居中
      4. space-between：两端对齐，子元素之间的间隔相等
      5. space-around：每个子元素的两端间隔相等，元素与元素之间的间隔比边缘两个元素距盒子边框间隔宽一倍
    - align-items：属性定义子元素在盒子的交叉轴上如何对齐
      1. flex-start：交叉轴的起点对齐
      2. flex-end：交叉轴的终点对齐
      3. center：交叉轴的中点对齐
      4. baseline：项目的第一行文字的基线对齐
      5. stretch：默认，如果项目未设置高度或设置为auto，将占满整个容器高度
    - align-content：定义多根轴线的对齐方式，如果只有一根轴线，则不起作用
      1. flex-start：与交叉轴的起点对齐
      2. flex-end：与交叉轴的终点对齐
      3. center：与交叉轴的中点对齐
      4. space-between：与交叉轴两端对齐，轴线之间的间隔平均分布
      5. space-around：每根轴线两侧的间隔都相等，轴线之间的间隔比与边框的间隔大一倍
      6. stretch：默认，轴线占满整个交叉轴

    子元素的属性：

    - order：定义子元素的排列顺序，值越小越靠前，默认为0
    - flex-grow：定义子元素放大比例，默认为0，如果均为1，则等分剩余空间
    - flex-shrink：定义子元素的缩小比例，默认为1，即如果空间不足自动缩小
    - flex-basis：定义在分配多余空间之前，子元素占据主轴的空间，默认auto
    - flex：flex-grow和flex-shrink和flex-basis的简写，后两个属性可选
    - align-self：允许单个子元素有与其他子元素不一样的对齐方式，可覆盖align-items属性，默认为auto，表示继承父元素align-items属性，如果没有父元素，则等同于stretch

  - float布局：

    - 两栏布局：任意一栏浮动居左或居右，另一栏设置overflow:hidden触发BFC；或者另一栏不管，在父元素上定义伪类，并在伪类中清除浮动
    - 三栏布局：同上思路，中间自适应的一栏放在最后编写，避免撑满盒子将另一栏浮动元素挤到下方
    
  - 单列布局：设置最大宽度，并用margin:0 auto居中

  - Grid网格布局：将容器划分为行和列，产生单元格，然后指定项目所在的单元格，设置为网格布局后，容器项目的float、display:inline-block、display:table-cell、vertical-align和column-*等设置都将失效

    - 容器属性：display：grid（块级元素）、display:inline-grid（行内元素）

      1. grid-template-columns：定义每一列的列宽

      2. grid-template-rows：定义每一行的行高，如：

         ```css
         /*等大三行三列*/
         .container {
           display: grid;
           grid-template-columns: 33.33% 33.33% 33.33%;
           grid-template-rows: 33.33% 33.33% 33.33%;
         }
         ```

      3. repeat()：简化重复的值

         ```css
         /*等大三行三列*/
         .container {
           display: grid;
           grid-template-columns: repeat(3,33.3%);
           grid-template-rows: repeat(3,33.3%);
         }
         ```

      4. auto-fill()：自动填充容器，当容器宽度不能放置更多列时换行

         ```css
         /*自动填充列，直到放不下的时候*/
         .container {
           display: grid;
           grid-template-columns: repeat(auto-fill,33.3%);
         }
         ```

      5. fr：指定网格的比例关系

         ```css
         /*第一列150px，第二列是第三列的一半宽*/
         .container {
           display: grid;
           grid-template-columns: 150px 1fr 2fr;
         }
         ```

      6. minmax()：指定长度范围，接受两个参数，分别为最小值和最大值

         ```css
         /*列宽不小于100px不大于1fr*/
         grid-template-columns: 1fr 2fr minmax(100px, 1fr);
         ```

      7. auto：表示由浏览器自己决定长度grid-template-columns: 1fr auto;表示第二列自动适配剩余宽度

      8. row-gap：设置行与行的间隔（行间距）

      9. column-gap：设置列间距

      10. gap：gird-row-gap与grid-column-gap的简写

          ```css
          /*行、列间距均10px*/
          row-gap: 10px;
          column-gap: 10px
          /*简写*/
          gap: 10px 10px 
          /*第一个值等于第一个值时可省略*/
          gap: 10px
          ```

      11. grid-auto-flow：指定容器子元素的自动放置顺序，默认为先行后列

          ```css
          /*先行后列*/
          grid-auto-flow: row
          /*先列后行*/
          gird-auwo-flow： column
          /*先行后列，尽量填满一行再填下一行*/
          grid-auto-flow: row dense;
          /*先列后行，尽量先填满一列再填下一列*/
          gird-auto-flow: column-dense
          ```

      12. justify-items：设置单元格内容的水平位置（左中右）

      13. align-items：设置单元格内容的垂直位置（上中下）

      14. place-items：align-items和justify-items的合并简写

          ```css
          /*对齐起始边缘*/
          justify-items: start;
          align-items: start;
          place-items: start
          /*对齐结束边缘*/
          justify-items: end;
          align-items: end;
          place-items: end
          /*居中对齐*/
          justify-items: center;
          align-items: center;
          place-items: center
          /*拉伸，占满单元格的整个宽度（默认状态）*/
          justify-items: stretch;
          align-items: stretch;
          place-items: stretch
          /*水平起始位置对齐，垂直居中*/
          palce-items: start center
          ```

      15. justify-content：整个内容区域在容器里面的水平位置（左中右）

      16. align-content：整个内容区域在容器里面的垂直位置（上中下）

      17. place-content：justify-content和align-content的合并简写

          - start：对齐容器的起始边框
          - end：对齐容器的结束边框
          - center：容器内部居中
          - stretch：拉伸占据整个网格容器
          - space-around：每个项目两侧间距相等，距边框的距离比项目之间的距离小一倍
          - space-between：两端对齐，每个项目之间间距相等
          - space-evenly：项目之间且项目与容器边框之间的间隔都相等

      18. grid-auto-columns：浏览器自动创建的多余网格的列宽

      19. grid-auto-rows：浏览器自动创建的多余网格的行高

      20. gird-template-areas：指定划分网格区域

    - 项目属性：

      1. grid-column-start：指定项目的左边框所在的垂直网格线定在哪根网格线

      2. grid-column-end：指定项目的右边框所在的垂直网格线定在哪根网格线

      3. grid-row-start：指定项目的上边框所在的水平网格线定在哪根网格线

      4. grid-row-end：指点项目的下边框所在水平网格线定在哪根网格线

         ```css
         /*左边框网格线1开始，右边框为网格线3，上边框为网格线2，下边框为网格线4*/
         grid-column-start: 1;
         grid-column-end: 3;/*span 2*/
         grid-row-start: 2;
         grid-row-end: 4;/*span 2*/
         /*如果存在重叠，可用z-index属性指定重叠顺序*/
         ```

      5. grid-column：是grid-column-start和grid-column-end的合并简写

      6. grid-row：是grid-row-start和grid-row-end的合并简写

         ```css
         grid-column: 1 / 3;/*1 / span 2*/
         grid-row: 2 / 4;/*2 / span 2*/
         ```

      7. grid-area：指定项目放在哪一区域，也可作为上面指定网格线的简写

         ```css
         grid-area: <row-start> / <column-start> / <row-end> / <column-end>;
         grid-area: 1 / 1 / 3 / 3;
         ```

      8. justify-self：设置单个项目单元格内容水平位置（左中右）

      9. align-self：设置单个项目单元格内容的垂直位置（上中下）

      10. place-self：justify-self和align-self的合并简写

  - 表格布局：

    ```css
    table    { display: table }
    tr       { display: table-row }
    thead    { display: table-header-group }
    tbody    { display: table-row-group }
    tfoot    { display: table-footer-group }
    col      { display: table-column }
    colgroup { display: table-column-group }
    td, th   { display: table-cell }
    caption  { display: table-caption }
    ```

- [ ] CSS3新特性

  - 选择器

  - 阴影：box-shadow：水平阴影位置 垂直阴影位置 模糊距离 阴影大小 阴影颜色 阴影开始方向（默认从里往外，设置inset即从外往里）

  - 边框：

    - 边框图片：border-image：url（）

      ```css
      /*铺满方式*/
      border-image-repeat：repeat(重复)、stretch（拉伸，默认）、round（铺满）
      /*边界宽度，默认为边框宽度*/
      border-image-width：10
      /*图形边界向内偏移*/
      border-image-slice：10
      /*指定边框外部绘制偏移量，默认0*/
      border-image-outset：0
      
      ```

    - 边框圆角

      ```
      border-radius：n1 n2 n3 n4 左上角，右上角，右下角，左下角
      ```

    - 背景

      1. background-clip：定制背景绘制区域，默认从边框开始绘制

         ```css
         /*默认*/
         background-clip：border-box
         /*从内边距开始绘制，不算border*/
         background-clip：padding-box
         /*只在内容区绘制，不算border和padding*/
         background-clip：content-box
         ```

      2. background-origin：搭配background-position使用，指定background-position的相对位置，分别为border-box，padding-box，content-box

      3. background-size：定制背景大小，可用百分比

  - 反射：-webkit-box-reflect：方向（above上，below下，right，右，left左） 偏移量 遮罩图片

  - 文字

    - 换行

      1. word-break：normal | break-all（只能在半角空格或连字符处换行） | keep-all（允许在单词内换行）
      2. word-wrap：normal | break-word（允许在长单词或URL地址内部换行）

    - 超出文本：

      1. 省略号：

         ```css
         /*单行*/
         overflow: hidden;
         white-space: nowrap;
         text-overflow: ellipsis
         /*多行*/
         overflow:hidden;
         text-overflow: ellipsis;
         display: -webkit-box;
         -webkit-line-clamp: 2
         -weblit-box-orient: vertical
         ```

    - 文字阴影：text-shadow:水平阴影 垂直阴影 模糊距离 阴影颜色

    - 颜色：

      1. rgba：rgb为颜色值，a为透明度
      2. hsla：hsla（色相，饱和度，亮度，透明度

  - 渐变：IE8 及更早版本的 IE 浏览器不支持该属性

    - 线性渐变：向下(to bottom)/向上(to top)/向左(to left)/向右(to right)/对角方向(to bottom right)（默认从上到下），也可指定角度deg

      ```css
      /*从上到下（默认）*/
      background-image: linear-gradient(#e66465, #9198e5);
      /*从左到右*/
      background-image: linear-gradient(to right, red , yellow);
      /*对角*/
       background-image: linear-gradient(to bottom right, red, yellow);
      /*指定角度*/
       background-image: linear-gradient(-90deg, red, yellow);
      /*使用多个颜色*/
      background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)
      /*重复线性渐变*/
      background-image: repeating-linear-gradient(red, yellow 10%, green 20%);
      ```

    - 径向渐变：以它的中心开始定义

      ```css
      /*颜色节点均匀分布(默认)*/
      background-image: radial-gradient(red, yellow, green);
      /*不均匀分布*/
      background-image: radial-gradient(red 5%, yellow 15%, green 60%);
      /*设置形状，可以为circle或则ellipse，默认ellipse*/
      background-image: radial-gradient(circle, red, yellow, green);
      /*重复径向渐变*/
      background-image: repeating-radial-gradient(red, yellow 10%, green 15%);
      ```

  - 2D转换：

    - translate()：根据X轴和Y轴的位置给定参数，从当前元素位置移动

    - rotate()：在一个给定的度数旋转元素，值为正数则为顺时针，值为负值则为逆时针

    - scale()：缩放大小，大小取决于X轴和Y轴的参数

    - skew()：倾斜度，参数分别为X轴的倾斜度和Y轴的倾斜度，第二个参数为空则默认为0，如果参数为负则表示向反方向倾斜

    - matrix()：

      ```css
      /*从左往右移动50px，从上往下移动100px*/
      transform: translate(50px,100px);
      -ms-transform: translate(50px,100px); /* IE 9 */
      -webkit-transform: translate(50px,100px); /* Safari and Chrome */
      
      /*rotate，顺时针旋转30度*/
      transform: rotate(30deg);
      -ms-transform: rotate(30deg); /* IE 9 */
      -webkit-transform: rotate(30deg); /* Safari and Chrome */
      
      /*将宽度放大2倍，高度放大3倍*/
      -ms-transform:scale(2,3); /* IE 9 */
      -webkit-transform: scale(2,3); /* Safari */
      transform: scale(2,3); /* 标准语法 */
      
      /*将元素在X轴和Y周上分别倾斜20度和30度*/
      transform: skew(30deg,20deg);
      -ms-transform: skew(30deg,20deg); /* IE 9 */
      -webkit-transform: skew(30deg,20deg); /* Safari and Chrome */
      ```

  - 3D转换：

    - rotateX()：围绕其在一个给定度数X轴旋转的元素

      ```css
      transform: rotateX(120deg);
      /*transform: rotate3d(1,0,0,120deg)*/
      -webkit-transform: rotateX(120deg); /* Safari 与 Chrome */
      ```

    - rotateY()：围绕其在一个给定度数Y轴旋转的元素

      ```css
      transform: rotateY(130deg);
      -webkit-transform: rotateY(130deg); /* Safari 与 Chrome */
      ```

      

  - 过渡：是元素从一种样式逐渐改变为另一种效果。

    - transition-property：none|all(所有属性)|property(属性名以逗号分隔)
  - transition-duration：过渡需要花费的时间
    - transition-timing-function：
      1. linear：规定以相同速度开始至结束
      2. ease：规定慢速开始，然后变快，然后变慢结束
      3. ease-in：规定以慢速开始的过渡效果
      4. ease-out：规定以慢速结束的过渡效果
      5. ease-in-out：规定以慢速开始和结束的过渡效果
      6. cubic-beziner(n,n,n,n)：自定义过渡速度效果，每个参数值从0到1
    - transition-delay：规定过渡效果何时开始
  
    ```css
  /*语法*/
    transition: 属性，花费时间，效果曲线（默认ease），过渡开始时间（默认0）
    /*将盒子从宽度100px扩展到300px，耗时2s*/
    div
    {
    	width:100px;
    	height:100px;
    	background:red;
    	transition:width 2s;
    	-webkit-transition:width 2s; /* Safari */
    }
    div:hover
    {
    	width:300px;
    }
    /*将盒子从宽高100px过渡到宽高200px，且顺时针旋转180度*/
    div {
        width: 100px;
        height: 100px;
        background: red;
        -webkit-transition: width 2s, height 2s, -webkit-transform 2s; /* For Safari 3.1 to 6.0 */
        transition: width 2s, height 2s, transform 2s;*/
    }
    div:hover {
        width: 200px;
        height: 200px;
        -webkit-transform: rotate(180deg); /* Chrome, Safari, Opera */
        transform: rotate(180deg);
    }
    ```
  
  - 动画：

    - 创建动画：@keyframes关键字创建动画，并在选择器中引用
  
      ```css
      div
    {
      	width:100px;
      	height:100px;
      	background:red;
      	animation:myfirst 5s;
      	-webkit-animation:myfirst 5s; /* Safari and Chrome */
      }
      @keyframes myfirst
      {
      	from {background:red;}
      	to {background:yellow;}
      }
      @-webkit-keyframes myfirst /* Safari and Chrome */
      {
      	from {background:red;}
      	to {background:yellow;}
      }
      ```
    
    - 关键字from...to..等同于0%和100%，from和0%是动画的开始，to和100%是结束，用百分比可以设置多段样式效果
    
      ```css
      @keyframes myfirst
      {
          0%   {background: red;}
          25%  {background: yellow;}
          50%  {background: blue;}
          100% {background: green;}
      }
      ```
    
    - @keyframes所有属性：
    
      1. animationname(必须)：动画名称
    
      2. animation：所有属性的简写
    
         ```css
         animation：name duration timing-function delay iteration-count direction fill-mode play-state;
         ```
    
      3. animation-name：动画名称，@keyframes创建的动画的名称
    
      4. animation-duration：设置动画完成所需时间
    
      5. animation-timing-function：从开始到结束动画的变化效果
    
         ```css
         linear:动画从头到尾的速度是相同的
         ease：默认。动画以低速开始，然后加快，结束前变慢
         ease-in：动画以低速开始
         ease-out动画以低速结束
         ease-in-out：动画以低速开始和结束
         cubic-bezier(n,n,n,n)：自定义速度，值为0-1的之间的数值
         ```
    
      6. animation-fill-mode：规定当动画不播放时，要应用到元素的样式
    
         ```css
         none：默认。动画在执行之前和之后不会应用到任何样式目标元素
         forwards：在动画结束之后，动画应用该属性值
         backwards：动画在启动动画或关键帧时应用该属性值
         both：同时遵循forwards和backwards
         initial：设置该属性为它默认值
         inherit：从父元素继承该属性
         ```
    
      7. animation-delay：定义动画什么时候开始，单位s或ms
    
      8. animation-iteration-count：定义动画应该播放多少次
    
         ```css
       n：一个数字，表示应该播放多少次，默认1次
         infinite：无限次
         ```
      
      9. animation-direction：定义是否循环交替反向播放动画
      
         ```css
         normal：默认。正常播放
         reverse：动画反向播放
         alternate：动画在奇数次（1、3、5...）正常播放，在偶数次（2,4,6...）反向播放
         alternate-reverse：在奇数次反向，偶数次正向
         initial：设置该属性为它默认值
         inherit：从父元素继承该属性
         ```
      
      10. animation-play-state：指定动画是否正在运行或已暂停
      
          ```css
          paused：指定暂停动画
          running：指定正在运动的动画
          ```
    
  - 多列：可设置文本的布局（IE9以及IE9以下的版本不支持）
  
    - column-count：指定需要分割的列数
  
    - column-gap：列之间的间隙
    
    - column-rule-style：列之间的边框样式
    
    - column-rule-width：列边框宽度
    
    - column-rule-color：列边框颜色
    
    - column-rule：column-rule-*的简写形式
    
    - column-span：指定元素跨越多少列，默认1列，all所有列
    
    - column-width：指定列的宽度
    
    - columns：columns: column-width column-count
    
      ```css
      /*分割三列且列宽100px*/
      -webkit-columns: 100px 3;
      -moz-columns: 100px 3;
      columns: 100px 3;
      /*间隙10px*/
      -webkit-column-gap: 10px;
      -moz-column-gap: 10px;
      column-gap: 10px;
      /*列边框*/
      -webkit-column-rule: 1px solid #ccc;
      -moz-column-rule: 1px solid #ccc;
      column-rule: 1px solid #ccc;
      /*跨越所有列*/
      -webkit-column-span: all;
      column-span: all;
      ```
    
  - 媒介查询
  
    - @media

      ```css
    /*语法*/
      @media mediatype(媒体类型) and|not|only (media feature) {}
      ```
  
    - 媒体类型：

      1. all：所有设备
    2. print：打印机
      3. screen：电脑，平板，手机
      4. speech：屏幕阅读器等发声设备
  
    - 媒体功能(media feature)：

      1. device-height：设备屏幕可见高度
    2. device-width：设备屏幕可见宽度
      3. max|min-device-height：设备屏幕可见最大或最小高度
      4. max|min-device-width：设备屏幕可见最大或最小宽度
      5. height：设备中的页面可见高度
      6. width：设备中的页面可见宽度
      7. max|min-height：设备中页面可见最大或最小高度
      8. max|min-width：设备中页面可见最大或最小宽度


## JS篇（6.22）

- [ ] 运算符

  - ++n：先自增，再取值
  - n++：先取值，再自增

- [ ] 循环方式

  - do-while：在对条件表达式求值之前，循环体内的代码至少会执行一次
  - while：先执行条件表达式求值，满足条件后才会执行循环体
  - for：先执行条件表达式求值，满足条件后才会执行循环体
  - for...in：用来枚举数组或对象属性，以任意顺序遍历一个对象的可枚举属性，更适合遍历对象，会遍历对象自身可枚举属性和继承可枚举属性
  - for...of：遍历可迭代对象，定义要迭代的数据，更适合遍历数组
  - break：跳出循环，执行循环后面的代码
  - continue：跳出本次循环，继续执行下一次循环

- [ ] 判断方式

  - if/else
  - if/ else if /else
  - switch

- [ ] 数据类型

  - undefined：声明了变量但未初始化
  - null：空对象指针
  - boolean
  - number
    - Number()：可转任何数据类型为Number类型
      1. true：1
      2. false：0
      3. null：0
      4. undefined：NaN
    - parseInt()：转为整数
    - parseFloat()：转为浮点类型
  - string
  - object
    - constructor：保存着用于创建当前对象的函数
    - hasOwnProperty(propertyName)：检查给定的属性在当前对象实例中是否存在（不是原型中）
    - isPrototypeOf(object)：用于检查传入的对象是否传入对象的原型
    - propertyIsEnumerable(propertyName)：检查属性是否可枚举
    - toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应
    - toString()：返回对象的字符串表示
    - valueOf()：返回对象的字符串、数值或布尔表示
  - symbol：表示独一无二的值，let a = Symbol('123')，其值不能与其他类型的值进行运算，可以显式转为字符串或布尔值，不可转为数值

- [ ] Date对象：var date = new Date()

  - Date.now()：当前时间
  
- getTime()：返回日期的毫秒数
  - setTime()：以毫秒数设置日期，会改变整个日期
  - getFullYear()：取得4位数的年份
  - getMonth()：取得月份，0-11
  
- getDate()：返回月份中的天数，1-31
  
  - getDay()：返回星期几，0表示星期天
  
- getHours()：返回日期中的小时数， 0-23
  - getMinutes()：返回日期中的分钟数，0-59
  - getSeconds()：返回日期中的秒数，0-59
  - getMilliseconds()：返回毫秒数
  
- [ ] RegExp类型：用来支持正则表达式

  - g：表示全局模式， var test = /at/g
  
- i：表示不区分大小写，var test = /at/i
  
  - m：表示多行匹配
  
- [ ] Math对象：

  - Math.max()|Math.min()：接收任意个数值作为参数，求得其中最大值或最小值

    ```js
    // 求数组中最大值
    Math.max.apply(Math, array)
    ```
  
  
  
- Math.ceil()|Math.floor()|Math.round()：向上|下|四舍五入取整
  
  - Math.random()：返回大于等于0小于1的随机数
  
  - Math.abs()：返回参数的绝对值

  - Math.pow(num, power)：返回num的power次幂

  - Math.sqrt(num)：返回num的平方根
  
- [ ] 数组以及其方法的基本用法

  - 数组检测：

    - instanceof：value instanceof Array，多框架时不准确
    - Array.isArray()：Array.isArray(value)，存在兼容问题
    - 安全方式：Object.prototype.toString.call(value) == "[object Array]"，万能

  - 转换方法：

    - toString()：返回由数组的每个项的字符串形式以逗号隔开的拼接而成的字符串
    - valueOf()：返回数组本身
    - toLocaleString()：与toString的区别在于转换时调用的是每一项的toLocaleString()
    - join()：默认以逗号分隔转换，可自定义分隔符

  - 栈方法：

    - push()：可接收任意数量的参数，并逐个添加到数组末尾，返回修改后数组的长度
    - pop()：从数组末尾移除最后一项，减少数组的length值，返回移除的项

  - 队列方法：

    - unshift()：在数组的首部添加一项，返回数组的长度
    - shift()：在数组的首部移除一项，返回移除的项

  - 重排序

    - sort(compare)：按升序排列，会把每个项转为字符串再比较
    - reverse()：反转数组顺序

  - 操作方法：

    - concat(数组|一个或多个元素)：合并数组，其思想是创建一个原数组副本，然后将接收的参数添加到这个副本的末尾，最后返回新构建的数组，如果参数为空，则直接返回这个副本。该方法不会改变原数组。

    - splice(起始位置，删除的个数，[插入的元素])：

      1. 删除：可以删除任意数量的项，只需指定起始位置和要删除的项数量
      2. 插入：可以向指定位置插入任意数量的项，传入起始位置、0、要插入的项，如果插入多项则一次列举
      3. 替换：向指定位置替换任意数量的项，指定起始位置，要删除的个数，要插入的任意数量的项，插入的项数与删除的项数可不一定相等

      返回删除的项组成的数组，会修改原数组。

    - slice(起始位置，结束位置（可选）)：如果参数只有1个，则返回原数组下标从参数开始到末尾的所有项组成的新数组，如果存在第二个参数，则返回起始与结束位置之间的所有项，不包括结束位置的项，不会改变原数组。

    - indexOf(要查找的项，起点位置(可选))：从数组开头向末尾查找，严格相等模式匹配，找到了返回在数组中的位置，否则返回-1

    - lastIndexOf(要查找的项，起点位置(可选))：从数组末尾向前查找，严格相等模式匹配，找到了返回在数组中的位置，否则返回-1

    - every(在每一项上运行的函数，函数运行作用域(可选，默认window))：运行参数函数，如果每一项都为true，则返回true，参数函数接收三个参数分别为数组项的值，该项在数组中的位置，数组本身

    - filter(在每一项上运行的函数，函数运行作用域(可选，默认window))：运行参数函数，返回所有返回true的项组成的一个新数组，参数函数接收三个参数分别为数组项的值，该项在数组中的位置，数组本身

    - forEach(在每一项上运行的函数，函数运行作用域(可选，默认window))：运行参数函数，不返回任何值，参数函数接收三个参数分别为数组项的值，该项在数组中的位置，数组本身

    - map(在每一项上运行的函数，函数运行作用域(可选，默认window))：运行参数函数，返回每次调用函数的结果组成的新数组，参数函数接收三个参数分别为数组项的值，该项在数组中的位置，数组本身

    - some(在每一项上运行的函数，函数运行作用域(可选，默认window))：运行参数函数，如果其中任意一项返回true，则返回true，参数函数接收三个参数分别为数组项的值，该项在数组中的位置，数组本身

    - reduce(每一项调用的函数，作为归并基础的初始值(可选))：从数组首项开始

    - reduceRight(每一项调用的函数，作为归并基础的初始值(可选))：从数组最后一项开始往前遍历

      参数函数接收4个参数：
    
      1. 前一次归并的值
      2. 当前的项值
      3. 当前项索引
      4. 该数组对象

- [ ] 手写实现数组各方法

  ```js
  // instanceof
  function _instanceof (L, R) {
    let r = R.prototype
    let l = L.__proto__
    while(true) {
      if (l === null) {
        return false
      }
      if (r === l) {
        return true
      }
      l = l.__proto__
    }
  }
  
  // isArray
  Array.prototype._isArray = function (arr) {
    if (Object.prototype.toString.call(arr) !== '[object Array]') {
      return false
    }
    return true
  }
  
  // toString
  Array.prototype._toString = function () {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    let str = ''
    let length = arr.length
    if (length === 0) {
      str = ''
    }
    if (length === 1) {
      str = arr[0]
    }
    if (length > 1) {
      for (let i = 0; i < length; i++) {
        if (i === length - 1) {
          str += arr[i]
        } else {
          str += arr[i] + ','
        }
      }
    }
    return str
  }
  
  // join
  Array.prototype._join = function (point) {
    let arr = this
    let p = point || ','
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    let str = ''
    let length = arr.length
    if (length === 0) {
      str = ''
    }
    if (length === 1) {
      str = arr[0]
    }
    if (length > 1) {
      for (let i = 0; i < length; i++) {
        if (i === length - 1) {
          str += arr[i]
        } else {
          str += arr[i] + p
        }
      }
    }
    return str
  }
  
  // push()
  Array.prototype._push = function () {
    let args = arguments
    let length = args.length
    if (length === 0) return
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    let arrL = arr.length
    for (let i = 0; i < length; i++) {
      arr[arrL++] = args[i]
    }
    return arrL
  }
  
  // pop()
  Array.prototype._pop = function () {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    let length = arr.length
    if (length === 0) {
      return
    }
    let lastItem = arr[length - 1]
    arr[length - 1] = null
    arr.length--
    return lastItem
  }
  
  // unshift()
  Array.prototype._unshift = function () {
    let args = arguments
    let length = args.length
    if (length === 0) return
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    let arrL = arr.length
    for (let j = arrL; j > 0; j--) {
      arr[j + length - 1] = arr[j - 1]
    }
    for (let i = 0; i < length; i++) {
      arr[i] = args[i]
      arrL++
    }
    return arrL
  }
  
  // shift()
  Array.prototype._shift = function () {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) return
    let result = arr[0]
    for (let i = 0; i < arr.length; i++) {
      arr[i] = arr[i + 1]
    }
    arr.length--
    return result
  }
  
  // sort()
  Array.prototype._sort = function () {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error("not Array")
    }
    let compare = arguments
    let length = compare.length
    if (length === 0) {
      for (let i = 0; i < arr.length - 1; i++) { // 两两相邻互换
        for (let j = 0; j < arr.length - 1 -i; j++) {
          if (arr[j] > arr[j+1]) {
            let temp = arr[j+1]
            arr[j+1] = arr[j]
            arr[j] = temp
          }
        }
      }
    }
    if (length > 0) {
      let fn = compare[0]
      for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - 1 -i; j++) {
          let result = fn(arr[j], arr[j+1])
          if (result < 0) {
            let temp = arr[j+1]
            arr[j+1] = arr[j]
            arr[j] = temp
          } else {
            continue
          }
        }
      }
    }
  }
  
  // reverse()
  Array.prototype._reverse = function () {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) {
      return arr
    }
    for (let i = 0, len = arr.length; i < len/2; i++) {
      let temp = arr[i]
      arr[i] = arr[len - 1 -i]
      arr[len - 1 -i] = temp
    }
    return arr
  }
  
  // concat
  Array.prototype._concat = function () {
    let args = arguments
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (args.length === 0) {
      return arr
    }
    let len = arr.length
    let resultArr = []
    // 深拷贝一份原数组
    for (let n = 0; n < len; n++) {
      resultArr[n] = arr[n]
    }
    for (let i = 0; i < args.length; i++) {
      if (Array.isArray(args[i])) {
        for (let j = 0; j < args[i].length; j++) {
          resultArr[len++] = args[i][j]
        }
      } else {
        resultArr[len++] = args[i]
      }
    }
    return resultArr
  }
  
  // splice
  Array.prototype._splice = function () {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arguments.length === 0) {
      return []
    }
    let idx // 第一个参数，起始下标
    if (arguments[0] < 0) {
      idx = arr.length + arguments[0]
      if (idx < 0) idx = 0
    } else {
      idx = arguments[0]
    }
    let num = arguments[1] // 第二个参数，删除的个数
    let ele = Array.prototype.slice.call(arguments, 2) // 第三个及以后的参数，要添加或替换到原数组的元素，这里直接用了slice，可以用for挨个遍历
    if (num > arr.length - idx) {
      // 最多删除到元素组最后一个元素
      num = arr.length - idx
    }
    let result = []
    for (let i = idx; i < idx + num; i++) {
      // 返回删除的项
      result.push(arr[i])
    }
    if (ele.length > 0) {
      // 插入或替换
      for (let i = arr.length-1, len = ele.length - num; i >= idx; i--) {
        // 从idx开始所有元素向后移len个长度
        if (len < 0) len = 0 // 防止覆盖起始下标之前的元素
        arr[i + len] = arr[i]
      }
      for (let j = 0; j < ele.length; j++) {
        arr[idx++] = ele[j]
      }
    } else {
      // 删除，后面的元素往前移num个位置，length-num
      for (let i = idx; i < arr.length; i++) {
        arr[i] = arr[i + num]
      }
      arr.length = arr.length - num
    }
    return result;
  }
  
  // slice
  Array.prototype._slice = function (start, end) {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) {
      return []
    }
    let s = start
    if (start < 0) {
      s = start + arr.length
    }
    let e = end || arr.length
    if (end < 0) {
      e = end + arr.length
    }
    if (e < s) {
      return []
    }
    let result = []
    for (let i = s; i < e; i++) {
      result.push(arr[i])
    }
    return result
  }
  
  // indexOf
  Array.prototype._indexOf = function (ele, start) {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) return -1
    let e = ele
    let s = start || 0
    let result = -1
    for (let i = s; i < arr.length; i++) {
      if (e === arr[i]) {
        result = i
        break
      }
    }
    return result
  }
  
  // every
  Array.prototype._every = function (fn, scope) {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) return false
    let sp = scope || window
    let result = true
    for (let i = 0; i < arr.length; i++) {
      let back = fn.call(sp, arr[i], i, arr)
      if (!back) {
        result = false
        break;
      }
    }
    return result
  }
  
  // filter
  Array.prototype._filter = function (fn, scope) {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) return []
    let sp = scope || window
    let result = []
    for (let i = 0; i < arr.length; i++) {
      let back = fn.call(sp, arr[i], i, arr)
      if (back) {
        result.push(arr[i])
      }
    }
    return result
  }
  
  // map
  Array.prototype._map = function (fn, scope) {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) return []
    let sp = scope || window
    let result = []
    for (let i = 0; i < arr.length; i++) {
      let back = fn.call(sp, arr[i], i, arr)
      result.push(back)
    }
    return result
  }
  
  // some
  Array.prototype._some = function (fn, scope) {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) return false
    let sp = scope || window
    let result = false
    for (let i = 0; i < arr.length; i++) {
      let back = fn.call(sp, arr[i], i, arr)
      if (back) {
        result = true
        break
      }
    }
    return result
  }
  
  // forEach
  Array.prototype._forEach = function (fn, scope) {
    let arr = this
    if (!Array.isArray(arr)) {
      throw new Error('not Array')
    }
    if (arr.length === 0) return
    let sp = scope || window
    for (let i = 0; i < arr.length; i++) {
      fn.call(sp, arr[i], i, arr)
    }
  }
  
  // reduce
  Array.prototype.myReduce =  function (fn, init) {
    if (!Array.isArray(this)) {
      throw new Error('not Array')
    }
    if (typeof fn !== 'function') {
      throw new Error('argument error')
    }
    var arr = this
    var total = init || 0
    for (var i = 0; i < arr.length; i++) {
      total = fn(total, arr[i], i, arr)
    }
    return total
  }
  ```

  

- [ ] 对象检测方式

  - in运算符：如果对象的自由属性或继承属性中包含这个被检测属性，则返回true

    ```
    被检测属性名 in 目标对象
    ```

  - hasOwnProperty()：检测被检测的属性是否为对象的自有属性，如果是返回true，继承的属性返回false

    ```
    目标对象.hasOwnProperty(属性名)
    ```

  - propertyIsEnumerable()：检测属性是对象的自有属性且是可枚举的，才会返回true

    ```
    目标对象.propertyIsEnumerable(属性名)
    ```

  - !==：判断一个属性在对象中是否为undefined，可以用来检测继承属性，true为存在，false为不存在（缺点是如果属性的值为undefined，也会返回false）

    ```
    目标对象.被检测属性 !== undefined
    ```


  - Object.getOwnPropertyDescriptor(对象，检测自有属性)：检测目标对象中是否存在检测的自有属性，如果存在则返回属性描述，否则返回undefined

- [ ] 原型、原型链基本原理及其应用

  - 原型：
    1. 原型是一个对象
    2. 每个函数都有一个prototype属性，这个属性指向函数的原型，称为显式原型
    3. 每个对象都有一个`__proto__`属性它指向构造函数(constructor)的prototype属性，一个对象的原型就是它构造函数的prototype的属性值，因此`__proto__`表示对象的原型，称为隐式原型
    4. fn.prototype === fn.`__proto__`
  - 原型链：对象的`__proto__`也有自己的`__proto__`，层层向上，直到`__proto__`为null，而这种层层链接起来的数据结构就是原型链

- [ ] 创建对象的方式

  - 对象字面量
  - 构造函数
  - Object.create()：可实现继承

- [ ] 继承：子类可以访问父类的所有属性和方法，并且可以对这些属性和方法进行扩展

  - 原型链继承：利用原型让一个对象继承另一个对象的属性和方法，即把一个对象的原型作为另一个对象的实例，这样就可以继承另一个对象的属性和方法

    **缺点**：1.子类更改从父类继承过来的引用类型的属性，由于原型属性中的引用类型属性会被所有实例共享，因此会影响其他实例

    2.创建子类实例时，没有办法在不影响其他实例的情况下向超类型的构造函数中传参

    ```js
    var Super = function () {
      this.type = "super"
    }
    Super.prototype.getType = function () {
      console.log(this.type)
    }
    var Sub = function () {
      
    }
    Sub.prototype = new Super()
    var el = new Sub()
    el.getType() // super
    ```

  - 借用构造函数：在函数内部通过call或apply去继承超类型属性或方法

    **缺点**：未继承超类型的原型属性，无法做到函数复用

    ```js
    var Super = function (name) {
      this.type = name
    }
    Super.prototype.getType = function () {
      console.log(this.type)
    }
    var Sub = function (name) {
      Super.call(this, name)
    }
    var el = new Sub('sub')
    console.log(el instanceof Super) // false
    console.log(el.type) // sub
    ```

  - 组合式继承：使用原型链实现原型属性和方法的继承，使用借用构造函数来实现对实例属性的继承。

    **缺点**：无论如何都会调用两次父类

    ```js
    var Super = function (name) {
      this.type = name
      this.book = ['css', 'html']
    }
    Super.prototype.getType = function () {
      console.log(this.type)
    }
    var Sub = function (name) {
      Super.call(this, name)
    }
    Sub.prototype = new Super()
    Sub.prototype.constructor = Sub
    var el1 = new Sub('el1')
    var el2 = new Sub('el2')
    el1.book.push('js')
    console.log(el1.getType(),el1.book) // el1 ["css", "html", "js"]
    console.log(el2.getType(),el2.book) //el2 ["css", "html"]
    ```

  - 原型式继承：把一个对象作为另一个对象的基础，通过一个中介构造函数去创建一个实例。

    ```js
    // 方式1
    function object(o) {
      var F = function(){}
      F.prototype = o
      return new F()
    }
    var person2 = object(obj)
    // 方式2
    var person1 = Object.create(obj, {
    name: {
      value: 'person1'
    }})
    ```

  - 寄生式继承：创建一个用来封装继承过程的函数，在该函数的内部通过某种方式来增强对象，然后返回这个对象。

    ```js
    var obj = {
      name: 'obj',
      age: 18,
      book: ['css','js']
    }
    function createFn (obj) {
      var o = Object.create(obj)
      o.sayHi = function () {
        console.log('hi')
      }
      return o
    }
    var person2 = createFn(obj)
    ```

  - 寄生组合式继承：通过借用构造函数方式继承属性，通过原型链混成方式继承方法

    ```js
    var Super = function (name) {
      this.type = name
      this.book = ['css', 'html']
    }
    Super.prototype.getType = function () {
      console.log(this.type)
    }
    var Sub = function (name) {
      Super.call(this, name)
    }
    function createFn (Sub, Super) {
      var o = Object.create(Super.prototype)
      o.constructor = Sub
      Sub.prototype = o
    }
    createFn(Sub, Super)
    var person1 = new Sub('person1')
    ```

- [ ] this的9种情况的指向

  - 独立调用：指向window对象，在严格模式下，this会绑定到undefined
  - 对象方法中：this绑定的就是方法所在的对象，可访问到对象中所有属性
  - 函数中的this：函数中的this指向window，严格模式下为undefined
  - call或apply：this受call或apply指定的函数执行作用域影响，指定的是谁，this就绑定到谁上面
  - 构造函数：绑定到该构造函数创建的实例对象，如果构造函数有返回值，返回的是一个对象，那么this指向就是返回的这个对象，否则还是实例对象
  - 匿名函数：匿名函数的执行作用域为window，所以绑定到window对象上
  - 在事件中：在事件中绑定this，this指向的是这个事件的dom对象
  - 箭头函数：箭头函数本身没有this，它的this是来自其外层代码块中的this，箭头函数中的this始终指向其定义时所在的环境，因此箭头函数的this是固定不变的

- [ ] 函数的基础知识

- [ ] 闭包：在一个函数作用域中嵌套另一个函数，且另一个函数引用了外部函数作用域中的变量

  - 常见的闭包：
    - 将函数作为另一个函数的返回值
    - 将函数作为实参传递给另一个函数调用
  - 作用：
    - 延长函数作用域中的变量寿命，在闭包创建后，由于闭包的存在，该变量会一直处于被引用的状态，因此它的内存不会得到释放。
    - 函数作用域以外能够操作函数作用域内部的变量。
  - 闭包生命周期：
    - 产生：在嵌套函数被定义完成的时候就产生了闭包
    - 死亡：当嵌套的函数对象为垃圾对象的时候，就会被销毁
  - 内存溢出：当程序运行需要的内存超出了浏览器剩余的内存时，就出现内存溢出的错误
  - 内存泄漏：
    - 意外的全局变量
    - 没有及时清理的计时器或回调函数
    - 闭包

- [ ] 作用域、作用域链

  - 作用域：上下文声明的变量可作用的范围
    - 函数作用域：把变量定义在函数体内部，外部作用域无法访问包含在函数内部的任何变量，这样就构成了一个函数作用域
    - 块级作用域：
  - 作用域链：保证对执行环境有权访问的所有变量和函数的有序访问

- [ ] 变量声明方式、变量提升、暂时性死区

  - var：声明的变量存在变量提升
  - let：具备块级作用域，声明的变量不可提升
  - const：具备块级作用域，声明的是常量，不可修改，也不可提升

- [ ] DOM

  - 操作节点：

    - appendChild()：向末尾添加一个节点，返回新增的节点，如果该节点已存在，就从原来的位置移动到新位置
    - insertBefore(插入的节点，参照节点)：将节点插入指定位置，返回插入的节点
    - replaceChild(要插入的节点，要替换的节点)：替换指定节点，返回被移除的节点
    - removeChild()：移除节点，返回被移除的节点
    - cloneNode([true])：参数为true，执行深复制，复制节点及整个子节点，为false时复制节点本身

  - 访问节点：

    ```js
    Node.firstChild[lastChild | parentChild | nextSibling | previousSibling]
    ```

  - element类型：

    - nodeType值为1
    - nodeName的值为元素标签名
    - 属性操作：getAttribute()|setAttribute()|removeAttribute()
    - attributes：获取元素的属性集合
    - 创建元素：createElement()
    - 创建文本子节点：createTextNode()

  - 选择符：

    - querySelector()：参数为css选择器，返回与该选择器匹配的第一个元素，没找到返回null
    - querySelectorAll()：返回所有匹配的元素的集合

  - classList类别：

    - length：返回包含元素的个数
    - remove()：接收一个类名，从列表中删除给定类名
    - toggle()：如果列表中存在给定值，删除它，否则添加它
    - add()：将给定的字符串添加到列表中，如果已经存在，就不添加
    - contains()：表明列表中是否存在给定的值，存在返回true，否则返回false

- [ ] DOM2、DOM3

  - 元素大小：
    - 偏移量：
      1. offsetHeight/offsetWidth：元素宽高，包括滚动条和边框
      2. offsetLeft、offsetTop：元素外边框到包含元素内边框的距离
      3. offsetParent：保存着包含元素的引用
    - 客户区大小：
      1. clientWidth/cilenHeight：元素内容及内边距所占据的空间
      2. 视口宽度=document.body.clientWidth || document.documentElement.clientWidth
    - 滚动区大小：
      1. scrollHeight：在没有滚动条的情况下，元素内容总高度（内容+内边距）
      2. scrollWidth
      3. scrollLeft：被隐藏在内容区域左侧的像素数
      4. scrollTop：被隐藏在内容区域上方的像素数，通过设置该值可以让滚动条滚动到响应位置

- [ ] BOM

  - window：表示浏览器的一个实例，全局变量不能用delete删除，但是定义在window上面的全局属性可以删除

  - 窗口属性：

    - 获取视口：

      ```js
      let pageWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      ```

    - 窗口位置：

      ```js
      let leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;
      let top = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;
      ```

  - 系统对话框：window.print()

  - location对象：

    - hash：返回url的hash，即#号后面的内容，如果不存在则返回空
    - host：返回服务器名称和端口号
    - hostname：返回不带端口号的服务器名称
    - href：返回当前加载页面的完整url
    - pathname：返回url中的目录或文件名
    - port：返回url中指定的端口号
    - protocol：返回页面使用的协议
    - search：返回url中以？号开头的查询字符串
    - replace(url)：此方法不会在浏览器生成记录，用户不能回到当前页面
    - reload()：页面以最有效的方式重新加载，如果参数为true，则从服务器加载

  - navigator对象：

    - language：浏览器的主语言
    - appName：完整的浏览器名称
    - appVersion：浏览器版本
    - cookieEnabled：表示浏览器是否启用cookie
    - onLine：表示浏览器是否连接到了因特网
    - plugins：检测浏览器中安装的插件的数组

  - history对象：

    - go(0|[123]|-1|str)：如果是str，则会跳转到历史记录中包含这个字符串的位置
    - back()：退后一页
    - forward()：前进一页
    - length：保存着历史记录的数量

- [ ] AJAX

  - 什么是ajax：它是异步的JavaScript和xml，即使用XMLHttpRequest对象与服务器通信
  - XMLHttpRequest：
  - ajax请求步骤：
    1. 创建XMLHttpReques实例
    2. 创建响应回调函数
    3. 通过open()与服务器建立连接
    4. 通过send()向服务器发送数据
    5. 在响应回调函数中处理响应数据
  - open(请求方式，url，异步还是同步)
  - readyState：0未初始化、1已建立服务器连接、2请求已接收、3正在处理请求、4请求完成并且已准备好响应

- [ ] 线程、进程

  - 线程：是进程内的一个独立执行单元、是程序执行的一个完整流程，是CPU的最小调度单元
  - 进程

- [ ] 定时器

  - 定时器不能真正保证定时准确，一般会延迟一点点（在可接受的范围内），但是如果这个线程中还有一段计算量很大的代码在执行，那么就会延迟很多
  
- [ ] 防抖、节流

- [ ] 深拷贝

## ES6篇（7.15）

- [ ] var、let、const区别，const原理

- [ ] 数值扩展

  - Number.EPSILON：是JS表示的最小精度
  - Math.trunc(num)：将数值的小数部分抹去

- [ ] 数组扩展方法
  - 扩展运算符
    - 将一个数组转为用逗号分隔的参数序列
    - 可替代apply方法来把数组转为函数的参数序列
    - 可以深拷贝数组
    - 可以代替concat合并数组
    - 与解构赋值结合用于生成数组
    - 将字符串转为数组
  - Array.from()：将类似数组对象和可遍历的对象转为真正的数组
  - Array.of()：将一组值转为数组，解决了new Array()的局限性
  - copeWithin(开始位置，从开始位置读取数据，到该位置停止读取数据)：在当前数组内部，将制定位置的成员复制带其他位置去，会覆盖原有位置，返回修改后的数组。
  - find(fn(val,idx,arr)，执行作用域)和findIndex()：找出第一个符合条件的数组项
  - fill(填充的值，开始位置，结束位置)：填充一个数组，可以给空数组填充值，也可以覆盖数组中所有项
  - entries()：对数组的键值对遍历
  - keys()：对数组的键名遍历
  - values()：对数字的键值遍历
  - includes(值，起始位置)：检测数组中是否包含某个值
  - flat(嵌套层级)：将数组中嵌套的数组展开，变成一个一维数组并返回这个数组，不会改变原数组
  - flatMap()：对原数组每个项执行一次该函数，相当于先执行了map方法得到的结果再去执行flat方法，返回一个新数组，不改变原数组
  - 排序稳定性：指排序关键字相同的项，排序前后顺序不变
  
- [ ] 对象扩展方法

  - Object.is：判断两个值是否完全相等
  - Object.assign：合并对象
  - Object.setPrototypeOf(obj1, obj2)：设置obj2为obj1的原型对象
  - Object.getPrototypeOf(obj)：获取obj的原型对象

  - Object.getOwnPropertyNames(obj)：返回一个数组，包含obj对象自身的所有属性的键名（不包括symbol属性）。
  - Object.getOwnPropertySymbol(obj)：返回一个数组，包含对象自身的所有Symbol属性的键名
  - super关键字：指向当前对象的原型对象，只能在对象方法中使用
  - 链式判断运算符：onst firstName = message?.body?.user?.firstName || 'default';

- [ ] 解构赋值及其应用场景：从数组和对象中提取值，对变量进行赋值

- [ ] 迭代器iterator

  - 是一种接口，为各种不同的数据结构提供一个统一的访问机制，任何数据结构只要部署了iterator接口，就可以完成遍历

  - 工作原理：

    - 创建一个指针对象，指向昂前数据结构的起始位置
    - 第一次调用对象的next方法，指针自动指向数据结构的第一个成员
    - 不断调用next方法，指针一直往后移动，直到指向最后一个成员
    - 每调用next方法返回一个包含value和done属性的对象

  - 自定义遍历对象：创建symbol.iterator

    ```js
    let coolBoy = {
      name: 'giaogiao哥',
      sex: 'man',
      like: [
        '说唱',
        '一giao我一giao',
        '小卤蛋'
      ],
      [Symbol.iterator]() {
        let index = 0
        return {
          next: () => {
            if (index < this.like.length) {
              const result = {value: this.like[index], done: false}
              index++
              return result
            } else {
              return {value: undefined, done: true}
            }
          }
        }
      }
    }
    ```

- [ ] 生成器generator

  ```js
  // 用户数据 =》订单数据 =》商品数据
    function queryUser () {
      setTimeout(() => {
        let data = {
          userID: "111"
        }
        iterator.next(data.userID)
      }, 1000)
      
    }
    function queryOrder () {
      setTimeout(() => {
        let data = {
          orderId: "1222"
        }
        iterator.next(data.orderId)
      }, 1000)
    }
    function queryGoods () {
      setTimeout(() => {
        let data = {
          name: 'JS秘籍',
          type: 'ES6',
          money: '99.9',
          unit: '元'
        }
        iterator.next(data)
      }, 1000)
      
    }
    function * requestGen () {
      const userid = yield queryUser()
      console.log(userid)
      const orderid = yield queryOrder()
      console.log(orderid)
      const goods = yield queryGoods()
      console.log(goods)
    }
    let iterator = requestGen()
    iterator.next()
  ```

  

- [ ] set
  - Set不会添加重复的值
  - 可接收数组作为参数来初始化数据
  - 数组去重：[...new Set(array)]
  - 字符串去重：[...new Set(str)].join("")
  - Set内部，NaN === NaN
  - Set.add(value)：添加某个值，返回Set结构本身
  - Set.delete(value)：删除某个值，返回布尔值表示删除是否成功
  - Set.has(value)：返回一个布尔值，表示该值是否为Set成员
  - Set.clear()：清除所有成员，无返回值
  - 遍历方式：
    - Set.keys()：返回键名
    - Set.values()：返回键值
    - Set.entries()：返回键值对
    - Set.forEach()：使用回调函数遍历每个成员
    - for...of
  
- [ ] map
  - 可以把对象做为键名
  - 同一键名多次赋值，后一次覆盖前一次的值
  - size：获取长度
  - set(key,value)：设置键名以及对应的键值，返回整个map，如果键名存在，就更新值
  - get(key)：获取键名找键值，找不到就返回undefined
  - has(key)：返回一个布尔值，表示键名是否存在
  - delete(key)：删除某个键，成功返回true，失败返回false
  - clear()：清除所有
  - 遍历方法：
    - Map.keys()：返回键名
    - Map.value()：返回键值
    - Map.entries()：返回所有成员
    - Map.forEach()：遍历所有成员
  
- [ ] Class类：是一个语法糖，使对象原型的方法更加清晰，更像面向对象
  
  - 自带name属性，指向类名
  
  - class类内部定义的方法是不可枚举的，这一点跟构造函数不太一样
  - constructor：是类的默认方法，一个类必须有constructor方法，且该方法自动调用，如果没有手动定义，类会自动添加一个空的constructor方法；该方法默认返回实例对象(this)，可指定返回另一个对象。
  - 类必须使用new调用，否则会报错，这是和普通构造函数的一个主要区别
  - 类的所有实例共享一个原型对象
  - 取值函数getter()：
  - 存值函数setter()：
  - 类的属性名可以采用表达式
  - 类可以写成立即执行格式
  - 类不存在提升，这一点与ES5不同
  - Cenerator方法，在类定义方法的前面加*号，这个方法就是generator放法
  - 类中的this默认指向实例，如果把其方法单独使用，严格模式下会报undefined，可以用bind(this)或箭头函数去绑定this
  - 静态方法static：如果在类的方法前加一个static关键字，该方法不会被实例继承，而是直接通过类来调用
  - 静态方法中的this指向的是当前类，而不是实例，且静态方法可以和普通类方法重名
  - 子类可以调用父类的静态方法
  - 实例方法不仅可以定义在constructor方法内，还可以定义在类的顶部，不用写this关键字
  - 静态属性，在属性前面加static关键字，该属性就是静态属性
  - #号添加到属性前面或方法前面，表示私有属性和方法
  - 私有属性和方法前面加static关键字，表示静态私有属性和方法
  - 继承：
    - 通过extends关键字实现继承
    - 子类需要在constructor方法中使用super()方法来建立父类的this对象
    - 在子类中，如果没有使用super()方法，调用this关键字会报错
    - Object.getPrototypeOf(子类) === 父类，判断子类是否继承父类
    - super如果作为函数调用，指向的是父类构造函数，且不能在子类的方法中调用；如果作为对象调用，指向父类的原型对象，而在静态方法中，则指向父类
    - 在子类普通方法中通过super调用父类方法时，方法内部的this指向当前子类实例
    - 可以继承原生内置构造函数
    - Mixin：指多个对象合成一个新的对象，新对象具有各个组成成员的接口
  
- [ ] Promise各个方法以及手写实现promise

  - 状态：pending(进行中)、fulfilled(已成功)和rejected(已失败)，只要promise开始执行，中途任何操作无法改变其状态，一旦状态改变了，就不会再改变
  
  - 缺点：
    - 开始了就无法取消
    - 如果不设置回调函数，在promise内部抛出的错误无法反应到外部
    - 当处于pending状态时，不知道执行到了哪个阶段
    
  - promise是一个构造函数，接收一个函数作为参数，该函数分别由resolve和reject两个参数分别表示成功和失败
  
  - promise在创建后会立即执行其内部代码
  
  - 如果存在promise嵌套，那么内部的状态决定外部的状态变化
  
  - resolve或reject都是在promise事件循环末尾执行，因此即使在它们之后的代码会执行
  
  - then(resolved，rejected(可选))：then方法是为promise实例添加状态改变时的回调函数。
    
    - then方法返回的是一个新的promise对象，因此可以采用链式调用写法，链式调用后面的方法要等前面的方法状态改变后才会执行
    
  - catch()：用于指定发生错误时的回调函数，当状态为rejected时，调用该方法，执行过程中抛出的错误也会来到catch方法中；如果状态已经为resolved，然后再抛出错误是无效的。
  
  - finally()：无论promise最后是什么状态，都会在执行完then或catch的回调函数后执行该方法
  
  - all(Array)：将多个promise实例包装为一个新的promise实例
    - 只有在参数中所有实例状态都为fulfilled的时候，新promise实例才会变为fulfilled
    - 如果参数中存在一个实例状态为rejected，那么新promise实例的回调函数会接收这个被rejected的实例的返回值
    
  - race(Array)：类似all方法，它的参数中有一个实例的状态先改变，那么新promise的状态就跟着这个实例改变，并接收那个先改变的实例的返回值到回调函数中
  
  - allSettled(Array)：当所有实例都返回结果了，无论是fulfilled还是rejected，新实例才会执行结束，只要结束，状态一定是fulfilled，其回调函数接收一个状态组成的一个数组参数
  
  - any(Aaary)：如果参数实例中有一个变为fulfilled，那么最终状态就变为fulfilled，如果所有参数实例都变成rejected，最终状态才是rejected
  
  - resolve(obj)：将现有对象转化为promise对象，如果已经是promise对象则返回原对象；如果参数是个thenable（具有then方法的对象）,则转为promise对象之后立即执行then方法里面的代码；如果不传参，直接返回一个resolved状态的promise
  
  - reject(reson)：返回一个promise实例，状态为rejected。
  
  - 封装简易AJAX
  
    ```js
    let request = new Promise((resolve, reject) => {
      let xhr = new XMLHttpRequest()
      xhr.open('get', 'http://musicapi.leanapp.cn/comment/music?id=186016&limit=1')
      xhr.send()
    
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(xhr.response)
          } else {
            reject(xhr.status)
          }
        } 
      }
    })
    request.then(data => {
      console.log(data)
    })
    .catch(err => {
      console.log(err)
    })
    ```
  
    
  
- [ ] async、await
  - async：返回一个promise对象，内部return返回的值会成为then方法回调函数的参数
    - 内部抛出的错误会导致返回的promise对象状态变为reject，错误被catch接收
    - async内部异步操作执行完才会执行then方法指定的回调函数
  - await：后面跟一个promise对象，返回对象的结果，如不是promise对象，则直接返回对应的值；如果是一个thenable对象，则会将它等同于promise对象
    - 任何一个await后面的promise对象变为reject状态，那么整个ascyn函数也全部中断；如果把await放在try/catch内部，则不会影响其他await执行
  
- [ ] babel

  - 步骤：

    - 项目文件夹下安装@babel/core @babel/preset-env @babel/cli @babel/plugin-transform-runtime --save-D  npm install --save @babel/runtime

    - 在项目文件夹下创建.babelrc文件，并配置：

      ```js
      {
        "presets": [
          "@babel/env"
        ],
        "plugins": ["@babel/plugin-transform-runtime"]
      }
      ```

    - 运行命令npx babel 需要转码的文件路径 -d 转码到文件路径

    - npx browserify dist/js/app.js -o dist/js/bundle.js 将某个文件打包为另一个文件

    - 到html上用script标签引用打包后的js文件

- [ ] 可选链操作符 ?.：免去层层判断

  ```js
  let obj = {
      name: '111',
      like: {
          foot: 'apple',
          sports: ['篮球']
      }
  }
  let food = obj?.like?.foot
  ```

  

## 计算机网络篇（7.25）

- [ ] 计算机网络的分层模型
  - TCP模型分层：
    - 物理层
    - 数据链路层
    - 网络层
    - 传输层
    - 应用层
  
- [ ] DNS服务器和跨域问题
  - DNS查找过程
    - 客户端向本地域名服务器发出请求，请求www.baidu.com
    - 本地DNS服务器向DNS根服务器发出请求，根DNS服务器会告诉本地服务器(.com)的服务地址
    - 本地DNS服务器会向.com域发请求，会得到baidu.com的服务器地址
    - 本地DNS服务器会向baidu.com发请求，会得到www.baidu.com的ip地址
    - 本地DNS服务器向客户端回复域名对应的ip地址
  
- [ ] IP地址、MAC地址
  - MAC地址：48位的二进制组成，通常分为6段，用16进制表示
  - IP地址：由32位二进制组成，将网络分为ABC三类
    - IP地址中全为1即255.255.255.255时，称为限制广播地址
    - IP地址中全为0即0.0.0.0，表示启动时的IP地址，其含义是尚未分配时的IP地址
    - 127表示本机测试，除了127.255.255.255，其他127开头的地址都代表本机
  
- [ ] 代理、本地存储、跨域

  - 同源策略：协议、域名、端口号一致

  - 跨域解决办法：
    - jsonp：由于浏览器对script标签的src属性、link的ref属性、img的src属性是没有同源策略限制的，利用这一点可以将请求放在script标签的src属性里，再设置一个callback函数去处理响应过来的数据，如：<script src="https://sp0.baidu.com/xxx?callback=fn"></script>，这个方式只能支持GET请求，且不安全，容易发生XSS安全问题

    - postMessage：配合ifream使用

    - doucment.domain：仅限于同一域名下的子域

    - cors：需要后台配合进行相关的设置，后台设置可访问的域名白名单，在白名单内的域名才能够访问，还要设置请求头、请求方法

      ```js
      const http = require('http')
      const whitList = ['http://localhost:4000'];
      http.createServer(function (req, res) {
        let origin = req.headers.origin;
        //在白名单中的域名才能访问
        if(whitList.includes(origin)){
          //允许的域名(* 所有域)，*不能和Access-Control-Allow-Credentials一起使用
          res.header("Access-Control-Allow-Origin", "*");
          //允许携带哪个头访问，不设置不能携带参数
          res.header("Access-Control-Allow-Headers","ContentType");
          //允许的方法，不设置默认支持GET、HEAD、POST，其他类型必须设置才能处理请求
          res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");
          //运行携带cookie，设置之后还能服务器才能接受cookie
          res.header("Access-Control-Allow-Credentials",true);
          //允许前端获取哪个头，不设置浏览器不能解析后台返回的参数
          res.header("Access-Control-Allow-Expose-Headers",'ContentType');
          if(req.method=== 'OPTIONS'){
              res.end()
          }
        }
      }).listen(9000, function () {
          console.log('server is runing at 9000')
      })
      
      ```

    - websocket：需要后台配合修改协议，不兼容，需要使用socket.io

      ```js
      //客户端
              let socket = new WebSocket('ws://localhost:3000');
              socket.onopen = function(){
                  socket.send('我很帅')
              }
              socket.onmessage = function(e){
                  console.log(e.data)
              }
      
      //服务端
      let express = require('express');
      let Websocket = require('wss');
      let wss= new WebSocket.Server({port:3000})
      wss.on('connection',function(ws){
          ws.on('message',function(data){
              console.log(data);
              ws.send('不要脸');
          })
      })
      let app = new express();
      app.listen(3000)
      
      ```

    - proxy：使用代理去避开跨域请求，需要修改nginx、apache等配置

      ```
      //nginx.conf
      location / {
          root;
          index index.html index.htm;
      }
      location ~.*\.json {
          root json;
          add_header "Access-Control-Allow-Origin" "*";
      }
      ```

  - cookie：

    - 限制大小，约4k左右，不适合存储数据量较大的值
    - 存在有效期，到期自动销毁，如果没有设置有效期，则在浏览器窗口关闭时自动销毁
    - 每次会随着http请求一起发送，浪费带宽
    - 设置了domain可以在子域共享跨域
    - 可以使用爬虫抓取

  - localstorage：

    - 存储数据量大，5M或更大
    - 永久有效，除非手动销毁
    - 不会随HTTP请求一起发送
    - 不能跨域
    - 浏览器隐私模式下不能读取
    - 不能被爬虫读取

  - sessionstorage：

  - 存储数据量大，5M或更大

  - 浏览器窗口关闭时销毁

  - 不会随HTTP请求一起发送

  - 不会被爬虫读取

- [ ] TCP/IP(传输控制协议/网际协议)
  - 网络分层
    - 应用层：邮件传输使用SMTP协议，万维网使用HTTP协议，远程登录服务使用TELNET协议
    - 传输层：格式化信息流、提供可靠传输，传输层协议规定接收端必须发回确认，如果有分组丢失，必须重新发送
    - 网络层：进行网络连接建立和终止以及IP地址的寻找等功能
    - 数据链路层：接收IP数据报并通过网络发送
  - 拥塞控制
  - 三次握手四次挥手
  
- [ ] UDP

- [ ] HTTP

  - 几种请求方法：
    - get：发送请求来获取服务器上的资源
    - post：想url指定的资源提交数据或附加新的数据，来获取特定的资源
    - put：类似post，但put指定了资源在服务器上的位置，而post没有
    - head：只请求页面的首部
    - delete：删除服务器上的某个资源
    - option：获取当前url支持的方法，如果请求成功会有一个Allow的头部包含类似“get，post”这样的信息
    - trace：用于激发一个远程的应用层的请求消息回路
    - connect：把请求连接转换到透明的TCP/ip通道

  - URL的构成：

    http://(协议)www.xxx.com(主机)/index.html(路径)?name=xxx&age=xxx(参数)

  - 常见状态码：
    - 1xx：信息状态码
    - 2xx：成功状态码
      - 200，ok，正常返回信息
      - 201，created，请求成功并且服务器创建了新的资源
      - 202,Accepted，服务器已经接受了请求，但尚未处理
    - 3xx：重定向
      - 301，请求的网页已永远移动到新位置
      - 302，临时重定向
      - 303，临时重定向，且总是使用get请求新的URL
      - 304，自上次请求后，请求的网页资源未修改过，表示可以直接读取缓存，不用重新在服务器加载数据
    - 4xx：客户端错误
      - 400，服务器无法理解请求的格式
      - 401，请求未授权
      - 403，禁止访问
      - 404，找不到匹配URL的资源文件
    - 5xx：服务器错误
      - 500，常见的服务器错误
      - 503，服务器暂时无法处理请求，可能是过载或正在维护

  - 版本

    - 0.9：仅支持GET请求，不支持请求头
    - 1.0：一次请求建立一次TCP连接，请求完成就断开，如果存在多个请求就要建立多次。支持GET/POST/HEAD请求方法，长连接使用时要添加请求头connection：keep-alive
    - 1.1：一次TCP连接可以有多次请求，支持PUT、DELETE、PATCH、OPTIONS方法，默认长连接，设置connection：close时关闭长连接，增加了缓存处理如：cache-control和实体标签etags
    - 2.0：多路复用，即新增了二进制分帧层，在二进制分帧层上，HTTP2.0会将所有传输信息分割为更小的消息和帧，并对其采用二进制格式编码，其中首部信息封装到Header帧，请求体封装到Data帧里，在性能上有很大的提升，实现了低延迟高吞吐量

  - 存在的问题：

    - 请求信息明文传输，容易被窃听截取
    - 数据的完整性未校验，容易被篡改
    - 没有验证对方身份，存在冒充危险

- [ ] HTTPS：

  - HTTPS = HTTP + SSL，即https在http的基础上通过传输加密和身份认证保证了传输过程的安全性
  - 

- [ ] XSS：跨网站指令码，也称跨站脚本攻击，是一种网站应用程式的安全漏洞攻击，是代码注入的一种，它允许恶意使用者将程式代码注入到网页上，这类攻击通常包含了HTML以及脚本语言

  - 种类：
    - 存储型
      - 将恶意代码提交到目标网站的数据库中
      - 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器
      - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
      - 恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户的行为，调用目标网站接口执行攻击者指定的操作
    - 反射型：跟存储型的区别在于反射型是恶意代码存在URL中
    - DOM-based：取出和执行恶意代码由浏览器端完成，属于前端JS自身的安全漏洞，存储型和反射型是属于服务端的安全漏洞
  - 攻击方式：
    - 通过修改HTML节点或执行JS代码来攻击网站
    - 在内联的JavaScript中，拼接的数据突破了原本的限制(字符串，变量，方法名等)
    - 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或标签
    - 在标签的href、src等属性中，包含JavaScript：等可执行代码
  - 防范：
    - 在输入时对文本进行html实体编码，在服务端也做一次html实体编码
    - 在输出时对内容进行一次html实体编码
    - 通过正则去过滤特殊标签和属性
    - 严格控制输入的格式，不要相信用户的输入

- [ ] CSRF：跨站请求伪造，攻击者盗用了用户的身份，以用户的名义发送恶意请求

  - 创建方式：

    - 当用户登录了受信任的网站A，浏览器会在本地存储A的cookie
    - 然后用户去访问了另一个恶意网站B，B会去获取本地浏览器存储到的cookie
    - 然后B拿到用户在A网站的cookie去请求A网站，就能拥有用户的权限，伪造用户的操作去进行恶意请求

  - 危害：

    - 篡改目标网站上的用户数据
    - 盗取用户的隐私数据
    - 作为其他攻击的辅助攻击手段

  - 防范：

    - 验证码，验证码必须在受信任的网站上发送给浏览器，伪造网站不能获取到受信任网站发送的session，因此无法伪造验证码

      refer，标识当前请求的页面源，如果受信任网站每次都去判断了请求的页面源是当前网站的请求，就可以通过请求，否则拦截请求。但是网站源可以被篡改，所以不是特别安全

    - token，服务器发送给用户的令牌，且token是随机组成的，拥有校验码，不容易被篡改，也不容易去拿到

- [ ] DDOS：

- [ ] 缓存

  - 缓存优点：
    - 减少不必要的数据传输，节省带宽
    - 减少服务器的负担，提升网站的性能
    - 加快了客户端加载网页的速度
    - 用户体验友好
  - 缺点：资源如果有更改但是客户端不及时更新会造成用户获取信息滞后，如果老版本有bug的话，情况可能会更糟糕

  - 强缓存：cache-control

    - max-age：表示缓存的时间为XXX秒，如：max-age=10，表示缓存10秒
    - public：表示可以被浏览器和代理服务器缓存
    - immutable：表示该资源永远不变，实际是为了让用户点击刷新网页的时候浏览器不会去请求服务器，而是从本地内存中去读取缓存并返回200状态
    - cache-control：max-age=xxx,public：表示客户端和代理服务器都可以缓存该资源，客户端在xxx秒内有效，如果在xxx秒内请求资源的话就直接读取缓存，返回code200，如果用户手动刷新页面，浏览器再向服务器发出http请求
    - cache-control：max-age=xxx，private：表示只让浏览器再xxx秒内缓存该资源，而代理服务器不能缓存
    - cache-control：max-age=xxx，immutable：浏览器的该缓存在xxx秒内有效，如果请求该资源就直接读取缓存，如果用户刷新了网页，也不会向服务器发起http请求
    - cache-control：no-cache：表示跳过设置强缓存，不妨碍设置协商缓存
    - cache-control：no-store：不缓存，浏览器和服务器都不缓存，也就没有强缓存和协商缓存了

  - 协商缓存

    - etag：每个文件的hash，当文件改变了就变化
    - last-modified：表示文件的修改时间，精确到秒
    - 流程：在请求资源事，把用户本地该资源的etag与last-modified同时带到服务端，服务端和最新的资源做对比，如果资源没有更改，就返回code304，浏览器直接读取本地缓存，如果资源有改变，则返回200，返回最新的资源
    - 为什么要有etag？
      - 一些内容可能未更改而仅仅是时间进行了修改，就会重新去更新资源，etag就是可以利用etag来判断文件是否改变，来解决这个问题
      - 如果修改频率很高，不在last-modified的精确度范围内，则不会进行资源的更新，etag能用来检测文件改变情况，也解决了这个问题
      - 某些服务器不能精确的得到文件的最后修改时间

  - 设置强缓存与协商缓存：

    - 后端服务器，如node中：

      ```js
      res.setHeader('max-age': '3600 public')
      res.setHeader(etag: '5c20abbd-e2e8')
      res.setHeader('last-modified': Mon, 24 Dec 2018 09:49:49 GMT)
      ```

      

- [ ] 常见请求头

  - Host：初始化url中的主机和端口号
  - Content-Type：请求体或响应体类型，如text/plain、application/json
    - text/html：HTML格式
    - text/plain：纯文本格式
    - text/xml：XML格式
    - image/gif：gif图片格式
    - image/jpeg：jpg图片格式
    - image/png：png图片格式
    - application/xml：XML数据格式
    - application/json：Json数据格式
    - application/pdf：pdf格式
    - application/msword：word文档格式
    - application/octet-stream：二进制流数据(比如文件下载)
    - application/x-www-form-urlencoded：form表单数据被编码为key/value格式发送到服务器
    - multipart/form-data：表单中文件上传时用到的格式
  - Content-Encoding：请求体或响应体的编码格式
  - Accept：可接受的响应内容的类型
  - Accept-Charset：浏览器可接受的字符集
  - accept-encoding：浏览器能够进行解码的数据编码方式，如：gzip
  - accept-language：浏览器所希望的语言种类
  -  Authorization：授权信息
  - Connection：浏览器优先使用的连接类型，如keep-alive、upgrade
  - content-length：表示请求消息正文的长度
  - cookie：服务器通过set-cookie设置的一个HTTP协议cookie
  - Etag：给当前资源的标识，用于缓存控制
  - Cache-Control：取值一般为no-cache或max-age=xxx，xx为整数，表示资源缓存有效期秒数
  - pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档
  - referer：包含一个URL，用户从该URL代表的页面发出访问当前请求的页面
  - origin：发起一个针对跨域资源共享的请求，该请求要求服务器在响应中加入一个`Access-Control-Allow-Origin`的消息头，表示访问控制所允许的来源。
  -  **User-Agent**：浏览器
  
- [ ] 常见响应头

  - Date：服务器的日期
  - Last-Modified：该资源最后被修改的时间
  - set-cookie：设置cookie
  - location：重定向到另一个URL
  - Server：后台服务器

## 数据结构与算法基础篇（8.10）

- [ ] hash

- [ ] 链表

- [ ] 二叉树

- [ ] 排序算法

  - 冒泡

    ```js
      // 把最小的排前面
        function sort1(arr) {
          let len = arr.length
          for (let i = 0; i < len; i++) {
            for (let j = i + 1; j < len; j++) {
              if (arr[i] > arr[j]) {
                let t = arr[j]
                arr[j] = arr[i]
                arr[i] = t
              }
            }
            console.log(`第${i}趟：${arr}`)
          }
          return arr
        }
        // 先把最大的排后面
        function sort2(arr) {
          let len = arr.length
          for (let i = 0; i < len; i++) {
            for (let j = 0; j < len - i -1; j++) {
              if (arr[j] > arr[j + 1]) {
                let t = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = t
              }
            }
            console.log(`第${i}趟：${arr}`)
          }
          return arr
        }
    
        // 每次最大的放后面，下一次遍历就忽视最后的排序完成的数
        function sort3(arr) {
          let flag = arr.length
          while(flag > 0) {
            let len = flag
            console.log(len)
            flag = 0
            for (let i = 0; i < len - 1; i++) {
              if (arr[i] > arr[i + 1]) {
                let t = arr[i]
                arr[i] = arr[i + 1]
                arr[i + 1] = t
                flag = i + 1
              }
              console.log(arr)
            }
          }
          return arr
        }
    ```

    

  - 快排

    ```js
    // 将数组取中位数，再比较每一个元素与中位数的大小，比它大放右边，比它小放左边，然后把左右两边分别再取中位数，重复开始的操作，最后拼接成的数组就是排序后的数组
    // 优点：代码少，容易理解；缺点，复杂度高，内存消耗大
    let quickSort = function (arr) {
        let len = arr.length
        if (len <= 1) {
          return arr
        }
        let harf = arr.splice(len / 2, 1)
        len--
        let left = [],
            right = [];
        for (let i = 0; i < len; i++) {
          if (arr[i] < harf) {
            left.push(arr[i])
          } else {
            right.push(arr[i])
          }
        }
        return quickSort(left).concat(harf,quickSort(right))
      }
    
    // 2.取基数，基数取开始下标和结束下标之和的一半，然后从开始下标向后遍历，记录比基数大的下标i，从结束下标向前遍历，记录比基数小的下标j，如果i<=j,就让这两个位置的元素互换位置，由于位置已互换，下一次遍历就要跳过这两个位置，所以从i++和j--这两个位置继续执行上述操作。直到i > j时，这一轮的遍历才结束，返回i，如果i小于最初的开始下标，就把i作为结束位置，继续递归排序，否则把i作为开始位置，继续递归遍历
      var devide = function (array, start, end) {
            if(start >= end) return array;
            var baseIndex = Math.floor((start + end) / 2), // 基数索引
                 i = start,
                 j = end;
    
            while (i <= j) {
                while (array[i] < array[baseIndex]) {
                    i++;
                }
                while (array[j] > array[baseIndex])  {
                    j--;
                }
    
                if(i <= j) {
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                    i++;
                    j--;
                }
            }
            return i;
        }
    
        var quickSort = function (array, start, end) {
            if(array.length < 1) {
                return array;
            }
            end = end || array.length - 1
            start = start || 0
            var index = devide(array, start, end);
            if(start < index -1) {
                quickSort(array, start, index - 1);
            }
            if(end > index) {
                quickSort(array, index, end);
            }
    
            return array;
        }
    ```

    

  - 归并

    ```js
    // 1.先把数组以中间位置拆分，再把拆分后的两个数组再次拆分，依次拆分到只剩一个元素为止
    // 2.将最终拆分出来的组，进行两两循环比较，先把小的放进一个空数组，剩余最后的项自动push进数组尾部，返回这个已经排好序的数组，再回到上一层分组，继续进行循环比较
    // 3.最终得到排序完毕的数组，返回给外部
    
    let mergeSort = function (arr) {
          let len = arr.length
          if (len <= 1) {
            return arr
          }
          let middle = Math.floor(len / 2)
          let left = arr.slice(0, middle)
          let right = arr.slice(middle, len)
          console.log(left, right)
        // 递归分组
          return merge(mergeSort(left), mergeSort(right))
        }
        // 把相邻两组的元素排序
        function merge(left, right) {
          let result = []
          let ir = 0
          let il = 0
          while(ir < right.length && il < left.length) {
              // 把小的那个元素放在数组前面
            if (left[il] < right[ir]) {
              result.push(left[il])
              il++
            } else {
              result.push(right[ir])
              ir++
            }
          } 
            // 把剩余的元素添加进数组
          while(ir < right.length) {
            result.push(right[ir])
            ir++
          }
          while (il < left.length) {
            result.push(left[il])
            il++
          }
            // 返回排序好的分组，到上一层继续进行下一次排序
          return result
        }
    ```

    

  - 插入

    ```js
    // 1.取数组第一个元素为默认排序好的序列，然后从第二个开始往前遍历比较
    // 2.如果当前元素比其他元素小则继续往前遍历，且所有元素往后移动一位，如果比其他元素大则插入到这个位置
    // 3.完成一次插入再对后面的元素重复上面的操作
    function sertSort(arr) {
          if(arr.length <= 1) return arr
          for (let i = 1; i < arr.length; i++) {
            let key = i - 1
            let result = arr[i]
            while(key >= 0 && arr[key] > result) {
              arr[key + 1] = arr[key]
              key--
            }
            arr[key + 1] = result
          }
          return arr
        }
    ```

    

  - 选择

- [ ] 背包

- [ ] 动态规划

- [ ] 分治法

- [ ] 搜索算法

- [ ] 遍历算法

## 设计模式篇（8.20）

- [ ] 单例模式
- [ ] 工厂模式
- [ ] 观察者模式
- [ ] 发布订阅模式
- [ ] 装饰者模式
- [ ] 代理模式
- [ ] 适配器模式
- [ ] 策略模式

## webpack篇（9.5）

- [ ] 基本配置
- [ ] 插件开发
- [ ] 独立搭建

## VUE篇（9.10）

- [ ] 双向绑定原理
  
  - 通过Object,defineProperty方法的get与set对数据劫持并结合发布订阅模式，在数据更新时通知订阅者触发更新
  
- [ ] 响应式原理
  - 在vue初始化时，会通过调用Observe方法去递归遍历data数据属性值，并对每一个属性通过defineProperty方法进行数据劫持，在数据更新时在set中通知更新，在get中去依赖收集。
  - 同时初始化时还会调用complie方法去编译模板，在编译模板时会创建节点片段，完成指令的匹配与编译以及插值的匹配与编译，并创建watcher实例，把observe与complie之间建立桥梁，在数据改变时通知页面节点数据的改变
  
- [ ] 基本指令及其用法

- [ ] class及style绑定方式

- [ ] 组件及其通信方式

- [ ] 插槽

- [ ] 事件处理

- [ ] 过渡与动画

- [ ] 混入：可理解为一个函数的封装，把复用性高的业务逻辑或功能做拆分或组合，然后可以在其他组件中去引用。
  - 混入的顺序
    - 混入的钩子函数在所在的组件的钩子之前执行完毕
    - 混入与所在组件中data存在同名属性，组件的属性覆盖混入的属性
    - 混入与所在组件中methods、components、directives对象中存在同名方法，组件的方法覆盖混入的方法
  - 局部混入：在组件内部import混入元素，用mixin：[元素]的方式去使用
  - 全局混入：在入口文件中import混入元素，用vue.mixin(元素)的方式去使用
  
- [ ] 自定义指令

  - 全局创建方式：
    - Vue.directive(指令名，{})

  - 局部创建方式：
    - 外部引入指令到当前组件，使用directives去注册指令
    - 然后在元素标签上使用v-指令名去绑定指令值
  - 钩子函数：
    - bind：只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置
    - inserted：被绑定元素插入父节点时调用
    - update：所在组件的虚拟dom更新时调用，但是可能发生在其子虚拟dom更新之前。
    - componentUpdated：指令所在组件的虚拟dom及其子虚拟dom全部更新后调用
    - unbind：只调用一次，指令与元素解绑时调用
  - 钩子函数参数：
    - el：指令所绑定的元素，可以用来直接操作DOM
    - binding：一个对象，包含了指令名、绑定值、指令绑定的前一个值，传给指令的参数、字符串形式的指令值、修饰符对象
    - vnode：vue编译生成的虚拟节点
    - oldVnode：上一个虚拟节点
    - 注意：除了el之外，其他所有的参数都是只读，不可修改
  - 动态指令：
    - v-指令名:[参数]=“指令的值”，参数可以根据组件实例数据进行更新
    - binding.arg即可访问到动态指令参数
  - 多个指令值
    - 如果有多个指令值，可以以对象字面量的形式传递
  - 好处：可以避免在视图上写逻辑，做到把逻辑与视图分开

- [ ] 插件

  - 开发插件：暴露一个install方法，接受两个参数分别是Vue的构造器、可选的选项对象

    ```js
    MyPlugin.install = function (Vue, options) {
      // 1. 添加全局方法或 property
      Vue.myGlobalMethod = function () {
        // 逻辑...
      }
    
      // 2. 添加全局资源
      Vue.directive('my-directive', {
        bind (el, binding, vnode, oldVnode) {
          // 逻辑...
        }
        ...
      })
    
      // 3. 注入组件选项
      Vue.mixin({
        created: function () {
          // 逻辑...
        }
        ...
      })
    
      // 4. 添加实例方法
      Vue.prototype.$myMethod = function (methodOptions) {
        // 逻辑...
      }
    }
    ```

    

- [ ] 过滤器

- [ ] 渲染函数、JSX

  - render：模板渲染函数
    - 接收一个函数参数，createElement()
    - 接收一个context上下文参数
    - createElement：接收三个参数
      - 第一个参数（必填）：一个HTML标签名或者组件选项对象或者resolve了前两种任何一种的async函数
      - 第二个参数（可选）：一个与模板中的标签属性对应的数据对象
      - 第三个参数（可选)：子级虚拟节点（数组格式）或者文本虚拟节点（字符串）
    - 用JS来处理某些指令，如v-if、v-for、v-model
    - 绑定事件：on：{事件类型名,事件类型名,事件类型名...}
    - 可使用插槽和作用域插槽
  - JSX
    - 将h函数作为createElement的别名，可以直接在render中使用模板语法

- [ ] 单元测试

## vue-router篇（9.20）

- [ ] 路由基础

  - 动态路由：

    - 设置：{path: '/路径/:参数， component: 组件'}
    - 使用：this.$route.params

  - 嵌套路由：

    - 设置：
      - 在需要嵌套路由的组件中设置<router-view/>标签
      - 在路由配置文件中通过children属性去定义嵌套路由
      - 如果嵌套路由中的父级路由要能够访问到，可以为这个路由的添加一个path为空的子路由，并放在第一个

  - 编程式导航：

    - $router：访问路由实例

      ```js
      // 字符串
      router.push('home')
      // 对象
      router.push({ path: 'home' })
      // 命名的路由
      router.push({ name: 'user', params: { userId: '123' }})
      // 带查询参数，变成 /register?plan=private
      router.push({ path: 'register', query: { plan: 'private' }})
      ```

      如果提供了path，parmas会被忽略

      ```js
      const userId = '123'
      router.push({ name: 'user', params: { userId }}) // -> /user/123
      router.push({ path: `/user/${userId}` }) // -> /user/123
      // 这里的 params 不生效
      router.push({ path: '/user', params: { userId }}) // -> /user
      ```

    - $router.replace()：跳转并替换路由，不会向history添加记录

    - $router.push()：跳转路由，并会向history栈中添加新的记录

    - $router.go(n)：n为整数，表示在history记录中向前或者向后退n步

  - 命名路由：给路由设置name属性，之后可用name代替path去跳转路由

  - 命名视图：在<router-view/>标签上设置name属性，在路由配置中，components属性就依次以name属性值为键名，组件为键值，来完成命名视图配置，如果没有设置name属性，则默认键名为default

  - 重定向：路由配置中设置redirect属性指定跳转路由路径

  - 别名：路由配置中添加alias属性，这个属性值也是一个路径，这个路径就是这个路由路径的别名，它们访问的都是同一个视图

  - 路由组件传参：使用props属性解耦，在路由配置中设置props属性，属性值可以是对象，可以是函数或布尔值，在组件中的JS里定义props，以参数名为props的属性名即可使用该参数

  - History模式：

    - 设置：路由配置中，设置路由类型mode为history
    - 优化：在路由配置项的末尾配置一个通配符路由，表示404

- [ ] 路由守卫

  - 设置：在路由文件入口文件中，设置路由守卫

  - 守卫：

    - 全局签字守卫：router.beforeEach((to, from, next) => {})，当一个导航触发时，全局签字守卫按照创建的顺序调用

    - 全局解析守卫：router.beforeResolve，在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，被调用

    - 全局后置钩子：afterEach，该守卫不会接受next函数也不会改变导航本身

    - 路由独享守卫：在路由配置上直接定义beforeEach

      ```js
      const router = new VueRouter({
        routes: [
          {
            path: '/foo',
            component: Foo,
            beforeEnter: (to, from, next) => {
              // ...
            }
          }
        ]
      })
      ```

    - 组件内守卫：可以在组件内直接定义beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave

      ```js
      const Foo = {
        template: `...`,
        beforeRouteEnter (to, from, next) {
          // 在渲染该组件的对应路由被 confirm 前调用
          // 不！能！获取组件实例 `this`
          // 因为当守卫执行前，组件实例还没被创建
        },
        beforeRouteUpdate (to, from, next) {
          // 在当前路由改变，但是该组件被复用时调用
          // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
          // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
          // 可以访问组件实例 `this`
        },
        beforeRouteLeave (to, from, next) {
          // 导航离开该组件的对应路由时调用
          // 可以访问组件实例 `this`
        }
      }
      ```

      

  - 路由流程：

    - 导航触发
    - 在即将离开的组件中调用beforeRouteLeave
    - 调用全局的前置守卫beforeEach
    - 在重用的组件中调用beforeRouteUpdate
    - 调用路由独享守卫 beforeEnter
    - 解析异步路由组件
    - 在即将被激活的组件调用beforeRouteEnter
    - 调用全局的解析守卫 beforeResolve
    - 导航被确认
    - 调用全局的后置守卫 afterEach
    - 触发dom更新
    - 用创建好的实例调用beforeRouteEnter守卫里传给next回调函数

- [ ] 过渡动画

  - 单个路由过渡：在各个组件内使用transition并设置不同的name

  - 基于路由的动态过渡：

    ```js
    <!-- 使用动态的 transition name -->
    <transition :name="transitionName">
      <router-view></router-view>
    </transition>
    
    // 接着在父组件内
    // watch $route 决定使用哪种过渡
    watch: {
      '$route' (to, from) {
        const toDepth = to.path.split('/').length
        const fromDepth = from.path.split('/').length
        this.transitionName = toDepth < fromDepth ? 'slide-right' : 'slide-left'
      }
    }
    ```

  - 全局过渡：在router-view标签外部包裹transition标签

- [ ] 滚动行为，只在支持history.pushState的浏览器中可用

  - 创建方式：在创建Router实例时，提供一个scrollBehavior(to, from, savePosition)方法，savedPositon参数当且仅当popstate导航时才可用

    ```js
    // 让页面滚动到顶部
    scrollBehavior (to, from, savedPosition) {
      return { x: 0, y: 0 }
    }
    ```

    

- [ ] 懒加载

- [ ] 路由元

  - 定义方式：在定义路由时，可以配置meta字段，通过$route对象的$route.matched数组来访问这个字段

- [ ] 数据获取

## vuex篇（9.30）

- [ ] state
- [ ] getter
- [ ] mutation
- [ ] action
- [ ] module
- [ ] 表单处理

## 前端优化

- [ ] IOS滑动不顺畅问题

  - 在IOS5.0以及以后的版本，滑动有定义两个值分别为auto和touch，默认为auto

    ```css
    
    -webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */
    
    -webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */
    ```

  - 解决办法：

    - 在滚动容器上增加touch方法：

      ```css
      div {
          -webkit-overflow-scrolling: touch;
      }
      div::-webkit-scrollbar {
          display: none /*隐藏滚动条*/
      }
      ```

    - 设置overflow：

      ```css
      body {
      	overflow-y: hidden
      }
      div {
          overflow-y: auto
      }
      ```

- [ ] ios上拉下拉边界出现白色空白

  - 解决方案：

    - 监听事件禁止滑动：监听touchmove，让需要滑动的地方滑动，不需要滑动的地方禁止滑动

      ```js
      document.body.addEventListener('touchmove', function(e) {
          if(e._isScroller) return;
          // 阻止默认事件
          e.preventDefault();
      }, {
          passive: false
      });
      ```

    - 滚动妥协填充空白，装饰成其他功能：添加文字描述或loading效果

- [ ] 页面放大或缩小不确定性行为：双击或双指张开页面会放大或缩小

  - 解决方案：用mate的viewport属性来完成这点，设置maximum-scale和minimum-scale和user-scalable来控制放大缩小

    ```html
    <meta name=viewport content="width=device-width, initial-scale=1.0, minimum-scale=1.0 maximum-scale=1.0, user-scalable=no">
    ```

- [ ] click点击事件延时与穿透：点击蒙层上方的模块，由于click事件有300ms的延时，因此当蒙层消失了click事件穿透到蒙层下方的元素上

  - 解决方案：

    - 使用touchstart替换click

      ```js
      el.addEventListener("touchstart", () => { console.log("ok"); }, false);
      // vue中
      <button @touchstart="handleTouchstart()">点击</button>
      ```

    - 使用fastclick库

      ```js
      import FastClick from 'fastclick';
      FastClick.attach(document.body, options);
      ```

- [ ] 软键盘顶起页面，收起后页面未回落

  - 解决方案：

    - 监听页面高度变化，强制恢复弹出前的高度

      ```js
      // 记录原有的视口高度
      const originalHeight = document.body.clientHeight || document.documentElement.clientHeight;
      
      window.onresize = function(){
        var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;
        if(resizeHeight < originalHeight ){
          // 恢复内容区域高度
          // const container = document.getElementById("container")
          // 例如 container.style.height = originalHeight;
        }
      }
      ```

    - 如果是ios12+或wechat6.7.4+中，要先判断版本类型，再更改滚动的可视区域

      ```js
      const isWechat = window.navigator.userAgent.match(/MicroMessenger\/([\d\.]+)/i);
      if (!isWechat) return;
      const wechatVersion = wechatInfo[1];
      const version = (navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);
       
       // 如果设备类型为iOS 12+ 和wechat 6.7.4+，恢复成原来的视口
      if (+wechatVersion.replace(/\./g, '') >= 674 && +version[1] >= 12) {
          // 回弹
        window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight));
      }
      ```

- [ ] iphoneX系列安全区域适配问题

  - 解决方式：

    - 设置 meta标签的viewport-fit属性为cover，推荐使用sefe area inset变量

      ```css
      /* 适配 iPhone X 顶部填充*/
      @supports (top: env(safe-area-inset-top)){
        body,
        .header{
            padding-top: constant(safe-area-inset-top, 40px);
            padding-top: env(safe-area-inset-top, 40px);
            padding-top: var(safe-area-inset-top, 40px);
        }
      }
      /* 判断iPhoneX 将 footer 的 padding-bottom 填充到最底部 */
      @supports (bottom: env(safe-area-inset-bottom)){
          body,
          .footer{
              padding-bottom: constant(safe-area-inset-bottom, 20px);
              padding-bottom: env(safe-area-inset-bottom, 20px);
              padding-top: var(safe-area-inset-bottom, 20px);
          }
      }
      ```

      

## 反复复习阶段

- [ ] 把算法按类别罗列出来，每天随机抽取3-5题进行练习手写，并口头表述思想和过程
- [ ] 一周内把上面每一阶段知识都过一遍，并口头阐述

## 算法练习题（从8.10日开始每日2个，记录至下方）
